{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixel Wrangle Documentation","text":""},{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#2023-01-21-pixel-wrangle-pre-release-rc1","title":"2023-01-21 -&gt; Pixel-Wrangle - Pre-release - RC1","text":"<p>Please note that this is the first release candidate and it may contain unknown bugs. Use it for your projects at your own risk.</p> <p>Tests were run on a Windows system, an AMD CPU, an RTX 3XXX GPU, and the latest version of TouchDesigner 2022. If you encounter any critical bugs, please let us know in the issues section of the repository.</p> <p>The documentation is currently in a 'work in progress' state and will be updated soon. It will be available in both French and English.</p>"},{"location":"Changelog/#features","title":"Features","text":"<ul> <li>Compute shaders, 2D array buffers, and 3D are all supported, with 100% functional parity with GLSLMultiTOP.</li> <li>All GLSL TOP parameter types are now supported, with an additional \"Header\" type parameter to aid in parameter layout in the Controls page.</li> <li>All parameter properties are available for customizing appearance.</li> <li>Ability to save your own functions/snippets to build your custom GLSL library.</li> <li>External library auto-parser to convert any arbitrary GLSL library (in the \"Functions/dist\" folder of the Pixel-Wrangle root) to a TD-compatible GLSL library (correcting paths and old syntaxes).</li> <li>One-click to parse and import all external libraries in your project (with static path resolving).</li> <li>One-click to export your shader in a new PanelCOMP (removing the Pixel-Wrangle dependency).</li> <li>The UI has been completely rebuilt, allowing you to customize the main background color, text size, text font, and text line height.</li> <li>Built-in mouse interactions are available everywhere while hovering a viewer and holding the [CTRL] key.</li> <li>A variety of macros have been added for common operations.</li> <li>Fuzzy search (and path-based) to find relevant functions and presets.</li> </ul>"},{"location":"Changelog/#improvements","title":"Improvements","text":"<ul> <li>All Pixel-Wrangle related data has been moved to a USER folder (Documents/Pixel-Wrangle) including vscode environment, cached code panes, saved presets and functions, and macros.</li> <li>The function loader now has preview hints (documentation headers and signatures)</li> <li>Keyboard shortcuts have been updated</li> <li>All parameters have hover-over help when the ALT key is held down</li> <li>Most of the UI elements have help message on hovering</li> <li>Non-default parameters are now always saved with presets (including resolution, bit depth, shader mode, etc.)</li> <li>Integration with Visual Studio Code has been improved and is now more stable</li> <li>The official documentation and Lygia are both integrated as submodules, see the installation instructions for more information.</li> <li>Crashes are now extremely rare.</li> </ul>"},{"location":"Changelog/#known-bugs","title":"Known bugs","text":"<ul> <li>Loading presets is still buggy, you may need to load them twice.</li> <li>Most keybindings are slightly sticky (but still usable).</li> <li>Releasing the [CTRL] key after an interaction in the parameter pane viewer will reset the mouse position to the last main viewer position.</li> <li>Navigation in the presets and functions browser with arrow keys does not allow you to press and hold to scroll through the list, and the left arrow key collapses all opened directories (so, it is recommended to use your mouse instead).</li> <li>Some cacheTOP in subnet may cook unnecessarily after loading a preset. Toggling the time dependency generally solves the problem.</li> </ul>"},{"location":"Changelog/#quick-install","title":"Quick Install","text":""},{"location":"Changelog/#requirements","title":"Requirements","text":"<ul> <li>TouchDesigner 2022.29530 or later</li> <li>Git</li> </ul>"},{"location":"Changelog/#installation","title":"Installation","text":""},{"location":"Changelog/#manual","title":"Manual","text":"<ul> <li>Use Git to clone the repository with all its submodules at the root of your Palette folder located in Documents/Derivative</li> </ul> <pre><code>git clone --recurse-submodules https://github.com/miu-lab/Pixel-Wrangle.git\n</code></pre> <ul> <li>Update your Palette</li> </ul>"},{"location":"Changelog/#automatic","title":"Automatic","text":"<ul> <li>Download and execute setup.sh (with Git Bash) provided in the Release section</li> <li>Update your Palette</li> </ul>"},{"location":"en/","title":"Index","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/","title":"Coding with Pixel-Wrangle","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#introduction","title":"Introduction","text":"<p>Pixel Wrangle offers a pixel shader development environment involving an underlying GLSL TOP. It therefore uses the GLSL language because it inherits from GLSL TOP. GLSL TOP is a GLSL implementation offered by Touchdesigner in its own ecosystem, it fits into the workflow of TOPs (Texture Operators in the Touchdesigner terminology). For more information on the GLSL language, visit the [[GLSL]] page. For more information on TOPs in Touchdesigner, go here.</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#overview-of-the-pixel-wrangle-editor","title":"Overview of the Pixel Wrangle editor","text":"<p>Editing code in Pixel Wrangle is divided into 3 tabs in the en/index:</p> <ul> <li>The IO tab which contains the 'Inputs' (your 'uniform' variables) and 'Outputs' (the shader's output buffers) panels. These panels have specific syntax which is detailed further -&gt; Coding with Pixel Wrangle</li> <li>The Functions tab which houses all the code outside the main() function. You can declare your custom functions, macros, shared variables, etc. there.</li> <li>The Main tab which corresponds to the body of the main() function. You do not need to declare this function within your code, just write your code as you would in the main() function.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#execution-order","title":"Execution order","text":"<p>The code content of the 3 tabs is parsed, then sent to the compiler in the following order:</p> <ol> <li>Macros</li> <li>IO -&gt; Inputs (uniform)</li> <li>Functions -&gt; imports with #include + function declarations</li> <li>IO -&gt; Outputs (Buffers)</li> <li>Main (main() function with your code inside)</li> </ol> <p>To view the complete code (once parsed: that is, as it is sent to the compiler), you can consult the 'Full Code Panel' ([CTRL] + 9)</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#attention","title":"Attention","text":"<ul> <li>Both the 'Functions' and 'Main' tabs use standard GLSL syntax, so you can write code exactly as you would in any GLSL shader.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#but","title":"BUT","text":"<ul> <li>The 'IO' tab has a special syntax, explained in detail below</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#io-tab-specifics","title":"IO tab specifics","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#inputs-panel-uniform-variables","title":"Inputs panel (uniform variables)","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#syntax-specifics","title":"Syntax specifics","text":"<ul> <li>Each of the variables you declare in the Inputs panel are uniform variables mapped to a Touchdesigner parameter.</li> <li>No 'uniform' keyword, it is implicit and is added automatically when parsing by Pixel Wrangle, before compilation.</li> <li>Your uniform variable name reflects the name of the associated Touchdesigner parameter.</li> <li>Consequently, your variable name must absolutely start with a capital followed by lowercase letters only, and NO special characters or '_' (constraint of Touchdesigner parameter names)</li> <li>The type of the variable determines the type of the Touchdesigner parameter that will be associated with it, following the same scheme as your uniforms declarations in a GLSL TOP</li> <li>**Any line of code starting with '//' or '/*' is considered a comment, EXCEPT Specific cases (Headers)</li> <li>**Any variable declaration or comment must be made on a single line.</li> <li>**To customize the Touchdesigner parameter associated with your uniform variable, you can add a comment after the declaration of your variable followed by pairs of property=value detailed here</li> <li>Modifiable properties reflect what you could do via the Component Editor, no more.</li> <li>**Each property must be followed by a '=' sign then its value.</li> <li>**Each [property=value] pair must be separated by a ';'</li> <li>The list of modifiable properties is available below, in the 'Modifiable properties' section</li> <li>Properties whose value is a string must not be enclosed in ' or \", but written directly as they are.</li> <li>However, properties whose value is an array of string must be written in the form [ 'Menu Entry 1' , 'Menu Entry 2' ]\\ with ' or \" enclosing each element of the array.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#specific-cases-headers","title":"Specific cases (Headers)","text":"<ul> <li> <p>Header type parameters are available although they have no meaning at the GLSL level, as they are useful for formatting the UI.</p> </li> <li> <p>The syntax for creating a Header type parameter is '//--- '.</p> </li> <li>You can then associate a label and/or section property with it.</li> </ul> <p>For example: '//--- label=Noise Types; section=1' will create an UI parameter of type Header, with the title: 'Noise Types', and will have a separator above it.</p> <ul> <li>Other parameters not compatible as 'uniform' with GLSL TOP such as 'File' or 'Folder' types are not available through the IO panel.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#correspondence-of-glsl-types-td-parameter-styles","title":"Correspondence of GLSL Types / TD parameter styles","text":"GLSL Type TD Parameter Style Syntax int Int OR Menu OR Toggle OR Pulse int Newint; float Float float Newfloat; vec[2-4] Float of size [2-4] OR Color for vec[3-4] vec3 Newcolor; uvec[2-4] Int of size [2-4] OR Color for vec[3-4] uvec2 Newunsignedvec; ivec[2-4] Int of size [2-4] OR Color for vec[3-4] ivec2 Newsignedvec; bvec[2-4] Int of size [2-4] OR Color for vec[3-4] bvec2 Newboolvec; \\&lt;TYPE&gt;[*] CHOP vec4 Newvectorarray[16] =&gt; !! Array of 16 vec4 values, needs to be referenced by a CHOP that holds the corresponding channels !! mat4 CHOP mat4 Newmatrix; atomic_uint Int atomic_uint Newatomicint; const int Int OR Menu OR Toggle OR Pulse const int Newconstantint = 0;"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#modifiable-properties","title":"Modifiable properties","text":"Syntax Description Default Value label Parameter Label Parameter Name section Parameter has separator 0 order Parameter UI order (position) integer =&gt; Same as your declaration order readonly Parameter Lock 0 enable Parameter Activation 1 enableExpr Parameter Activation Expression '' help Parameter Help text on hover '' style Parameter Style Float or Color (for vec3-4) or Str or CHOP (according to variable type). Can be modified for int, float, vec3-4 (Valid values =&gt; Menu, Color, Toggle, Pulse, Float, Int) expr Parameter Expression '' bindExpr Parameter Bind Expression '' menu Parameter Menu entries (integer type only) '' default Parameter Default Value 0 or '' min Minimum Parameter Value 0 max Maximum Parameter Value 1 toggle Parameter is a toggle (integer type only) '' pulse Parameter is a Pulse (integer type only) '' chop Parameter chop path (mat4 type only) ''"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#examples","title":"Examples","text":"<pre><code>/* Syntax example */\n// Single line comments are ignored by the parser\n// Except for header (when line start with //---)\n//--- label=Simple Parameters; section=1\n// Create Float Parameter\nfloat Float; // default=0; min=-1; max=1; section=1\n// Create Integer Parameter\nint Int;     // min=-10; max=10; default=0\n//--- label=Vector Parameters; section=1\n// Create Color Vector Parameter\nvec3 Color;  // default=[0, 0.7, 1]; section=1\n// Create Vector style Parameter\nvec3 Position;  // default=[0, 0.7, 1]; style=Float\n//--- label=Menu Parameters; section=1\n// Create Menu Parameter\nint Newmenu;                  // menu=['Tomatoes', 'Bananas']; default=1; section=1\n//--- label=Array Parameters; section=1\n//// Create a uniform array of vec2 (you will need to specify a CHOP target with 2 channels and 16 samples each)\n// vec2 Array[16];\n//// Create a texture buffer array of vec4 (you will need to specify a CHOP target with 4 channels and 200 samples each)\n// vec4 Array[200];\n//// Create Matrix Parameter (you will need to specify a compatible 'chop' like transformCHOP to remove warning)\n// mat4 NewMatrix;\n/* Vulkan Specialization Constants */\nconst int ConstanttypeMenu = 0;     // menu=['Candies', 'Sky']; label=Vulkan Constant Menu\n//--- label=Atomic Counters; section=1\n// Create Atomic Counter\natomic_uint NewAtomicCounter; // section=1\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#outputs-panel-buffers","title":"Outputs panel (Buffers)","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#generalities-within-glsl-top","title":"Generalities within GLSL TOP","text":"<p>Buffers are variables that allow storing and sharing data between different shaders or different rendering stages. They are useful for accumulating data and communicating between the different shaders of a rendering pipeline.</p> <p>Here are the 2 most used forms within the Touchdesigner GLSL TOP:</p> <ul> <li> <p>Texture buffers (Accessible in Vertex/Pixel AND Compute mode): They allow referencing textures that will be used for display. They are generally used in shaders to READ texture pixels and use them to influence the final color of the pixel.</p> </li> <li> <p>Image buffers (Accessible in Compute mode ONLY): They allow READING AND WRITING to image data buffers such as textures or offscreen renderings. They are generally used in shaders to perform image processing operations.</p> </li> </ul> <p>It is also possible to declare image texture buffers with dimensions greater than 2 (for example, a 3D texture or a 3D image).</p> <p>It is important to note that texture buffers and image buffers cannot be used interchangeably. Each has its own syntax and its own access functions.</p> <p>Also, it should be noted that image buffers can be accessible for reading and writing but only in 'Compute Shader' mode, refer to the Pixel Wrangle or GLSL TOP parameters page to adjust this option (Output Access).</p> <p>Regarding texture buffers: they are accessible in READ ONLY mode but available in both modes (Vertex/Pixel AND Compute)** with the texture() function.</p> <p>Furthermore, within a Pixel Shader in 'Compute' mode, the use of texelFetch() is more appropriate for reading texture data as it generally offers better performance while allowing the management of mipmap levels (or LOD =&gt; Level Of Detail).</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#examples-in-a-glsl-top","title":"Examples in a GLSL TOP","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#vertexpixel-mode","title":"Vertex/Pixel Mode","text":"<pre><code>// Declare a buffer in Pixel/Vertex mode\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec4 otherColor;\nlayout(location = 2) out vec4 extraInfo;\nvoid main(){\n/* Assign a value to a buffer */\n// Write the red color to the 'fragColor' buffer\nfragColor = vec4(1,0,0,1); // Buffer 0 = Red\n// Write the color of the first 2D input, sampled with the normalized vUV.st coordinates provided by Touchdesigner.\notherColor = texture(sTD2DInputs[0], vUV.st); // Buffer 1 = Texture of the first input\n// Write the blue color to the 'fragColor' buffer\nextraInfo = vec4(0,0,1,1); // Buffer 2 = Blue\n}\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#compute-mode","title":"Compute Mode","text":"<pre><code>/*\nCompute shaders do not have an opinion on the type of data you provide them with, or on how to distribute calculations across the GPU. These aspects offer great flexibility but require determining in advance how you want calculations to be performed on your graphics card.\nFor more information on this, you can refer to the official GLSL documentation. For a brief explanation of the concept and its implementation in TD, visit https://docs.derivative.ca/Compute_Shader and https://docs.derivative.ca/Write_a_GLSL_TOP\n*/\n// Declare the size of the thread groups\nlayout (local_size_x = 8, local_size_y = 8) in;\n/*\nThe group size is used to determine how texture data is partitioned and distributed to threads on your GPU.\nFor example, if you use a 512 x 512 pixel texture and a group size of 8 x 8, you will need 64 thread groups to cover the entire texture.\nIf you leave the Auto-dispatch parameter on ON in the GLSL page settings, GLSL TOP will automatically assign the number of necessary groups to cover the full resolution chosen, so here: 64. (512/8 for each dimension).\nIn the other case, you will need to manually set the number of thread groups using the Dispatch Size parameter.\n*/\nvoid main(){\n// Define the color\nvec4 color = vec4(1,0,0,1); // Buffer 0 = Rouge\n// Write red color in Buffer 0\nimageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), color);\n}\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#managing-buffers-with-pixel-wrangle","title":"Managing buffers with Pixel Wrangle","text":"<ul> <li>Declare your buffers directly in the 'Outputs' panel of the 'IO' tab, in the same way, whether you are in Vertex/Pixel mode or Compute mode. In general (although there is no absolute rule), I recommend using CAPITAL NAMES to clearly differentiate your output buffers from your Inputs. Below is an example of declaring 3 output buffers</li> </ul> <pre><code>vec4 IMAGE;\nvec4 POSITION;\nvec4 NORMALS;\n</code></pre> <ul> <li> <p>Declare your buffers directly in the 'Outputs' panel of the 'IO' tab, always in the same way, whether you are in Vertex/Pixel mode or in Compute mode. In general (although there is no absolute rule), I recommend using names in CAPITALS to clearly differentiate your output buffers from your Inputs. Below is an example of declaring 3 output buffers.</p> </li> <li> <p>Pixel Wrangle creates the necessary outputs immediately with their respective names, you will see them appear on the OP instance as TOP type outputs.</p> </li> <li> <p>At the same time, a tab corresponding to each of your declarations will be visible in the 'Viewer' panels.</p> </li> <li> <p>Outputs are mapped in the order in which they were declared. If you want to change this order, you can change the order of your declarations.</p> </li> <li> <p>By default, each of these declarations dynamically adds a corresponding macro to easily access them in Compute Shaders. To take the previous example, this is what it looks like in the code sent to the compiler:</p> </li> </ul> <pre><code>#define IMAGE mTDComputeOutputs[0]\n#define POSITION mTDComputeOutputs[1]\n#define NORMALS mTDComputeOutputs[2]\n</code></pre> <ul> <li>Then, you can write to these buffers as follows from the 'Main' tab:</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#vertexpixel-mode_1","title":"Vertex/Pixel Mode","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shorthand for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1);\n/* Write vec4 'c' in 'IMAGE' Buffer, td() is a shorthand for TDOutputSwizzle() */\nIMAGE = td(c)\n/*\nTo learn more about the macros used above, you can go to the [Macros](./Macros.md) page, where you will find a complete list of macros that can be used in Pixel Wrangle. They can also be viewed from the 'Macros' panel in the upper left of the interface, or directly from the 'Full Code' panel as they are sent to the compiler.\n*/\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#compute-mode_1","title":"Compute Mode","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shortcut for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1);\n/* Write vec4 'c' in 'IMAGE' Buffer using Absolute Coordinates */\n// Shortcut for imageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), TDOutputSwizzle(c))\nstore(IMAGE, _UV, td(c));\n</code></pre>"},{"location":"en/Contribute/","title":"Contribute","text":"<p>I want to emphasize that I do not invite anyone to use Pixel Wrangle in productions that require stability above all else at this time.</p> <p>This project is in its early stages, so it is very likely that you will encounter bugs and that breaking changes will occur in the first iterations.</p> <p>Any RFE is obviously welcome via the dedicated section on the GitHub repo. However, I cannot guarantee flawless responsiveness at this time in terms of bug fixes and the implementation of new features (but I will do my best).</p> <p>On the other hand, if anyone is interested in helping me make this project a reality, I would be delighted to exchange and collaborate on this topic. Despite the fact that TD .tox are binaries, it is still possible to load scripts from the outside, so finally quite a few things are externalizable (including the most awkward Python scripts to date).</p> <p>Available to exchange, preferably via GitHub, or by email at the following address: studio.miu.lab@gmail.com</p>"},{"location":"en/Functions/","title":"Functions","text":""},{"location":"en/Functions/#external-libraries","title":"External libraries","text":""},{"location":"en/Functions/#introduction","title":"Introduction","text":"<p>Pixel Wrangle is designed as a modular environment.</p> <p>It is therefore possible to extend the available functions through existing GLSL libraries, or by building your own libraries by saving functionality that you can then recall in all your projects.</p> <p>This can be useful when you want to reuse code more granularly than you could with presets.</p> <p>Note also that when you import external libraries, they become available throughout your entire project, which means that you can fully reference these imports in a bare GLSL TOP, regardless of the use of Pixel Wrangle.</p>"},{"location":"en/Functions/#lygia","title":"Lygia","text":"<p>By default, Pixel Wrangle provides a very complete granular function library called Lygia.</p> <p>Lygia is a community project led by Patricio Gonzalez Vivo, who is also behind  https://thebookofshaders.com, an introduction to fragment shaders.</p> <p>For more information on this library and its content, you can also consult the Official GitHub</p>"},{"location":"en/Functions/#important-files-and-folders","title":"Important files and folders","text":"<p>Files related to external libraries are stored in your USER Functions folder, you can open it by clicking on the bottom right corner folder in Pixel Wrangle UI.</p> <p>To add an external library of your choice, you can clone its content into the Functions/\\ folder. <p>In the following sections, you will see how to integrate these libraries into your projects.</p> <p>I also specify that for the library to be readable by Pixel Wrangle, the files must have a '.glsl' extension, any other type of file will be ignored.</p>"},{"location":"en/Functions/#auto-parsing","title":"Auto-parsing","text":"<p>Pixel Wrangle provides a summary parsing tool that convert pure GLSL libraries compatible GLSL libraries with the Touchdesigner ecosystem.</p> <p>This mainly concerns the form of the import paths that are specific to Touchdesigner, but also the conversion of certain function names such as texture2D(), and others so that the library runs correctly in the Touchdesigner environment.</p> <p>The principle is as follows:</p> <ul> <li>You drop your raw library folders in your USER Functions folder as described above You parse your libraries directly from the Pixel Wrangle interface (Just press 'Import Libraries' from the 'Code/Plugin' page) Once the libraries are parsed, an automatically Touchdesigner-compatible copy of the file / folder architecture is made in the 'Functions/dist' folder.</li> </ul> <p>Then, the entire file/folder architecture at the root of your TouchDesigner project, in a BaseCOMP called 'libs'.</p> <p>Each '.glsl' import is actually a TextDAT in Sync File mode, which points to the corresponding file in the Functions/dist folder (the copy of the file after parsing).</p> <p>Since the library architecture is integrated into the root of your project, you can reuse all functions in a GLSL TOP context without going through the Pixel Wrangle envelope.</p>"},{"location":"en/Functions/#including-functions-in-your-pixel-wrangle-instance","title":"Including Functions in Your Pixel Wrangle Instance","text":"<p>By pressing the shortcut [CTRL] + [SHIFT] + [TAB], or clicking in the search bar at the bottom right of the interface, you can access the function explorer. This explorer returns a list of all functions available within your project. You can then search by typing a keyword, the list is automatically filtered.</p> <p>Pixel Wrangle will also provide header documentation for all your functions, as well as all the signatures that you can copy and paste directly into your code.</p> <p>Finally, you can double-click on the function in the list, which will import it into your Pixel Wrangle instance. You can see the inclusion appear in your 'Functions' panel.</p>"},{"location":"en/Functions/#adding-your-own-functions","title":"Adding your own functions","text":"<p>If you want to add new functions as you use Pixel Wrangle, you can do so using the '+' function in the Functions panel.</p> <p>You will then be asked for the name of the file to save as well as a header comment to provide useful information about the role of the file and its functions.</p> <p>By default, these presets are saved to the root of your Functions/user folder in a '.glsl' file. You can then place them in the directories of your choice and define the hierarchy of your choice in your project.</p>"},{"location":"en/Functions/#organize-your-functions-into-a-useful-library","title":"Organize your functions into a useful library","text":"<p>There is no particular method for creating your own GLSL function libraries, but some recommendations:</p> <ul> <li>Try to avoid creating dependencies on functions from other libraries to preserve portability of your library in different contexts</li> <li>As much as possible, try to organize your function files granularly and adopt a hierarchy by utility / context for clarity</li> <li>With the exception of overloading functions or declaring variations of signatures for the same function, it is recommended to have only one functionality per file.</li> </ul>"},{"location":"en/GLSL%20Language/","title":"GLSL Language","text":""},{"location":"en/GLSL%20Language/#generalities","title":"Generalities","text":"<p>GLSL is a compiled C-type language designed to create shaders. It was created and is maintained by the non-profit consortium Khronos Group, which is behind the open-source OpenGL standard (and now Vulkan, which will eventually replace OpenGL).</p> <p>A shader is a small computer program limited to a specific task. It is generally used to display things on the screen. GLSL shaders are run on your graphics processor (GPU).</p> <p>GLSL is able to intervene at several levels of the image rendering process. All the steps necessary to provide the final result are called the GLSL Language#Rendering Pipeline. Therefore, GLSL integrates into graphics applications using the OpenGL, Vulkan, WebGL APIs, and more.</p> <p>As of the 2022 builds, Touchdesigner integrates GLSL through Vulkan, the latest graphics API from Khronos, which will eventually replace OpenGL.</p> <p>The software provides an implementation of GLSL through two of its native operators: GLSL TOP (Texture) and GLSL MAT (Materials).</p> <p>It is important to note that GLSL shaders run in parallel on your machine, taking advantage of the power of graphics processors (GPUs) and offering very good performance for real-time applications.</p> <p>However, some programming basics are necessary to fully exploit the potential of shaders or adapt them to your own needs. In addition, programming a GPU (parallel calculation) requires a particular code structure and some constraints that may take some time to be understood.</p> <p>I highly recommend reading the excellent https://thebookofshaders.com, which helps to better understand these concepts, especially since much of the content is translated into many languages.</p> <p>Finally, GLSL is directly derived from the C language, so the syntax and semantics are very similar.</p> <p>However, there are some notable differences compared to C, including:</p> <ul> <li>A shortened syntax for manipulating vectors (called vector swizzling)</li> <li>A native library containing common mathematical functions as well as other functions specific to shaders</li> <li>Special types (matrices, samplers, etc.) dedicated to shader manipulation</li> <li>And many other things that I invite you to discover for yourself through the official documentation.</li> </ul> <p>You will also discover that some features of C are absent.</p> <p>For example, certain types such as strings do not exist in GLSL. This is partly due to the constraints imposed by the architecture of current GPUs and the way they perform calculations.</p> <p>Finally, you will find a list of useful links below for your journey.</p>"},{"location":"en/GLSL%20Language/#useful-links","title":"Useful Links","text":"<p>[!INFO]</p> <ul> <li> <p>An essential resource for getting started if you have never worked with shaders (The Book of Shaders).</p> </li> <li> <p>An overview of the language specifications in video.</p> </li> <li> <p>The official documentation of the language available on the Khronos website as a downloadable PDF.</p> </li> <li> <p>An index of functions included in the GLSL standard library.</p> </li> <li> <p>More details on the implementation of GLSL TOP (the underlying operator of Pixel Wrangle) in Touchdesigner.</p> </li> <li> <p>Shadertoy, a website that allows for the creation of shaders online using WebGL. It is a great place to find many examples of shaders created by the community.</p> </li> <li> <p>The website of Inigo Quiles is also a massive learning resource for understanding various mechanisms related to shader creation and the underlying math.</p> </li> <li> <p>Lygia is a community project led by Patricio Gonzalez Vivo (The Book of Shaders) among others, and is a library of GLSL (and HLSL) functions that provides a large number of very useful functions. It is natively provided with Pixel Wrangle and greatly facilitates work.</p> </li> <li> <p>Many YouTube videos cover shader creation. Some in the context of Touchdesigner, Unity, Shadron, glslsandbox, or other frameworks. The YouTube channel The Art Of Code, for example, offers a good introduction to GLSL on Shadertoy through practice.</p> </li> </ul>"},{"location":"en/GLSL%20Language/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>GLSL is a language that can be used at different stages of the rendering pipeline.</p> <p>Each stage of the pipeline has its own variables and functions.</p> <p>Here is a list (non-exhaustive and probably inaccurate in some places) of the stages of the pipeline, in chronological order:</p> <ul> <li> <p>Vertex Specification: This is the initial stage, which involves retrieving the list of points and primitives and their attributes (ID, position, etc.) from CPU memory and converting them into a format that can be used in the subsequent stages of the rendering pipeline in GPU memory. This step is automatically performed by Touchdesigner and the OpenGL/Vulkan backend when using a GLSL TOP on a Geometry COMP.</p> </li> <li> <p>Vertex Shader: This is a program that operates at the level of the geometry of a 3D object, and is executed simultaneously on each vertex of the input geometry. It allows, in particular, to create and modify attributes such as the position of points to deform an object, for example. The result of these operations is then passed on to the next stage of the rendering pipeline. Some intermediate steps can be performed at this stage (see Geometry Shaders, Tessellation Shaders...).</p> </li> <li> <p>Rasterization: Rasterization is an operation that transforms a scene described in a 3D space into a 2D image that can be displayed on a screen at a chosen resolution (discretization). You can imagine this step as the projection of our screen space (the view) onto the 3D objects in the scene. This operation is automatically and transparently performed by the OpenGL/Vulkan backend. There is no associated shader that allows for control over this stage of the pipeline, but it is crucial in the rendering pipeline.</p> </li> <li> <p>Pixel Shader (or Fragment Shader): This is a program that runs on each pixel rendered on the screen. A pixel shader allows you to manipulate this data to produce the final color of the pixels.</p> </li> </ul> <p>-&gt; In the case of a 3D object from a vertex shader, the Pixel shader performs an interpolation of the attribute values provided by the vertex shader. You can then manipulate them as you wish to obtain the desired result</p> <p>-&gt; In the case where no Vertex Shader is provided. Touchdesigner's Pixel shader implementation (GLSL TOP) provides 2 rectangle triangles by default that form a rectangle with the exact dimensions of the screen. You therefore have a coordinate system from which you can have fun. Note that it is quite possible to create 3D images without using a vertex shader or a geometry composed of points. This means that all the logic must be coded in the pixel shader. Raymarching (or 'Sphere Tracing') is one of these techniques. It is based on the description of shapes by distance fields called SDFs. You can find a lot of examples on Shadertoy and Inigo Quiles's website if you want to learn more about these techniques. As for raymarching in Touchdesigner, the rayTK project led by tekt is a wonderful example of porting this technique to the Touchdesigner environment. It greatly simplifies its use through a pre-constructed operator ecosystem. A tip, go see it!</p> <p>In Touchdesigner, GLSL can be used through GLSL TOP (Image generation in the TOP context) or GLSL MAT (Material generation for 3D objects).</p> <p>NB: The work environment provided by Pixel Wrangle currently only works with GLSL TOP.</p>"},{"location":"en/GLSL%20Language/#pixel-shader","title":"Pixel Shader","text":"<p>In the case of a pixel shader without a manually associated vertex shader (the default behavior of Pixel Wrangle), the thing you are actually manipulating within the main() function of your shader is the current pixel.</p> <p>This pixel has an intrinsic and fundamental characteristic, its position in screen space. In the case of a 2D image, for example, this is the x and y coordinates.</p> <p>It is important to understand that this same program is executed simultaneously on each of the pixels that make up your final image.</p> <p>For an image of 1024 1024 pixels, for example, this program will be executed 1024 1024 times, a total of 1,048,576 times. That's a lot.</p> <p>In the case of a standard processor (CPU), all these executions would be carried out sequentially (or at best, distributed across the few cores of your CPU).</p> <p>A CPU is very efficient for most everyday tasks with a computer and has fast and significant memory storage (RAM), but it is not very efficient when you need to perform the same processing on a large number of elements at the same time, as is the case with an image made up of pixels.</p> <p>On the contrary, a shader runs on your graphics processor (GPU). GPUs have a different architecture than CPUs, which is designed to execute a large number of tasks at the same time. For comparison, a GPU has a few thousand cores to more than 10,000 for high-end GPUs. This greatly reduces the number of operations performed at the same time, as the calculations are distributed among the thousands of cores of your GPU.</p> <p>The main limitations of the GPU:</p> <ul> <li>Limited memory space (VRAM is expensive and of fixed size), which implies a certain size and complexity limit for operations, more easily reached than with a CPU.</li> <li>A lower sequential execution speed (per GPU core) than your CPU.</li> <li>Current GPUs perform calculations with numbers only, making them difficult to use for tasks that manipulate strings of characters or certain types of complex data that are common in traditional programming.</li> <li>Abstraction capabilities are reduced, the scope of operations is limited.</li> </ul>"},{"location":"en/GLSL%20Language/#gpu-vs-cpu-by-example","title":"GPU vs CPU by example","text":"<p>CPU :</p> <ul> <li>Write 2 nested for loops, each iterating over the x and y coordinates of the image.</li> <li>Execute your main() function with all your code inside the 2 loops, on each of the pixels composing your image.</li> </ul> <pre><code>int ResolutionX = 1024;\nint ResolutionY = 1024;\nfor(int x=0; x&lt;ResolutionX; x++){\nfor(int y=0; y&lt;ResolutionY; y++){\n/* Intrinsic Attributes */\nuvec2 absolutePositionOfCurrentPixel   = uvec2(x,y);                                                           // -&gt; Absolute Coordinates   (with x and y integer values between 0 and Resolution-1)\nvec2 normalizedPositionOfCurrentPixel =  vec2(float(x)/float(ResolutionX-1),float(y)/float(ResolutionY-1));   // -&gt; Normalized Coordinates (with x and y float values between 0 and 1) =&gt; vUV.st\n/* Your main() function in a 2D Pixel Shader is executed here */\n// Your awesome stuff...\n// ...\n}\n}\n</code></pre> <p>Pixel Shader (GPU) :</p> <ul> <li>The coordinates are already provided by the main context through a variable called vUV in Touchdesigner.</li> <li>Just write your code in the main() function and retrieve the coordinates directly from the shader (vUV). This would have the following form for an image of 1024 * 1024 pixels: Within the main() function of a pixel shader, you can consider that each of your instructions is executed simultaneously, and the execution context is the internal part of this double 'for' loop.</li> </ul> <p>GLSL and Vulkan intelligently distribute the simultaneous execution of the program on all available cores of your GPU.</p>"},{"location":"en/GLSL%20Language/#pixel-coordinates","title":"Pixel Coordinates","text":"<p>In Touchdesigner, the normalized x and y coordinates are provided to you in the form of a vector in your shader through a variable directly provided by the execution context.</p> <p>This is the variable vUV</p> <pre><code>vec2 coords = vUV.xy; // Will store a copy of current XY coord in 'coords' vec2 variable\n</code></pre>"},{"location":"en/Keyboard%20Shortcuts/","title":"Keyboard Shortcuts","text":""},{"location":"en/Keyboard%20Shortcuts/#in-the-network-editor-with-the-pixel-wrangle-instance-as-the-current-op-green-borders","title":"In the Network Editor with the Pixel Wrangle instance as the 'Current OP' (Green Borders)","text":"Keyboard Shortcut Action [CTRL] + Enter Open Viewer in separate window for current selected Instance of Pixel Wrangle Escape Close Viewer for current selected Instance of Pixel Wrangle [CTRL] + F1 Set Perform window for current selected instance of Pixel Wrangle F1 Open Perform Window [CTRL] + R Reset all feedback inputs"},{"location":"en/Keyboard%20Shortcuts/#in-the-global-ui-window-of-the-current-instance","title":"In the global UI window of the current instance","text":"Keyboard Shortcut Action [CTRL] + 1 Switch to IO Tab or Toggle Code panes visibility [CTRL] + 2 Switch to Functions Tab [CTRL] + 3 Switch to Main Tab [CTRL] + 0 Toggle Full Screen Viewer [CTRL] + 9 Toggle Full Code Panel (Read-Only) [CTRL] + = Export shader in a new PanelCOMP [CTRL] + M Toggle Macros Panel (Read-Only) [CTRL] + T Toggle Time Dependency [CTRL] + P Toggle Parameter Panel [CTRL] + H Toggle Online Help [CTRL] + R Reset all feedback inputs [CTRL] + [SHIFT] + P Toggle Viewer in Parameter Panel [CTRL] + [SHIFT] + E Open Visual Studio Code [CTRL] + [SHIFT] + I Import all libraries in your project (in /libs) [CTRL] + Tab Open Preset Loader Panel [CTRL] + [SHIFT] + Tab Open Functions Loader Panel"},{"location":"en/Keyboard%20Shortcuts/#in-main-tab","title":"In Main tab","text":"Keyboard Shortcut Action [CTRL] + [SHIFT] + 1 Toggle IO Tab in Main Tab on Left Side [CTRL] + [SHIFT] + 2 Toggle Functions Tab in Main Tab on Right Side"},{"location":"en/Keyboard%20Shortcuts/#in-a-viewer-panel","title":"In a Viewer panel","text":"<p>All shortcuts for TOPs are available in addition to the following:</p> Keyboard Shortcut Action [1-8] Switch Tab on corresponding Output Holding [CTRL] + Click Interaction Mode (Mouse Position, Mouse Clicks)"},{"location":"en/Macros/","title":"Macros","text":""},{"location":"en/Macros/#generalities","title":"Generalities","text":"<p>In GLSL, macros are instructions that allow for defining reusable code. They are similar to C macros and are defined using the <code>#define</code> directive. Macros can be useful for simplifying code and making it more readable, but it is important to be careful not to abuse them as they can make the code difficult to understand and debug. By definition, macro evaluation occurs at compile time (static), not at runtime. This means that they cannot be modified during the execution of the program, unlike uniform variables for example. Therefore, their use cases are different.</p> <p>Voici un exemple de d\u00e9finition de macro simple :</p> <pre><code>#define PI 3.14159265\n</code></pre> <p>In this case, each occurrence of <code>PI</code> in the code will be replaced with the value <code>3.14159265</code> during compilation.</p> <p>We can also define macros with more complex expressions, which act as functions with arguments for example:</p> <pre><code>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n</code></pre> <p>In this case, when the <code>MIN</code> macro is used in the code with arguments, it is replaced by the conditional expression that compares the two arguments and returns the smallest of the two. For example, the <code>MIN(x, y)</code> instruction will be replaced by <code>((x) &lt; (y) ? (x) : (y))</code>.</p>"},{"location":"en/Macros/#important-files","title":"Important files","text":"<p>You will find in the /Macros folder of the repo, the files containing all the macros pre-declared by Pixel Wrangle in your shaders. Feel free to add your own. The following table lists all the macros that Pixel Wrangle makes available to you.</p>"},{"location":"en/Macros/#accessible-variable-macros-in-pixel-wrangle","title":"Accessible Variable Macros in Pixel Wrangle","text":"Macro name Macro value Comment _PI 3.1415926535897932384626433832795 PI Value (3.14...) _TAU _PI * 2 2 * PI Value _GOLD 1.618033988749894 Golden Ratio _E 2.7182818284590452353602874713527 Euler Number _RES vec2(uTDOutputInfo.res.z,uTDOutputInfo.res.w) 2D Resolution in Pixels _DEPTH uTDOutputInfo.depth.y Depth _RATIO2D vec2(max(_RES.x/_RES.y, 1),max(_RES.y/_RES.x, 1)) Ratio from Max Axis _CENTER 0.5 Center _POS2DN vec2(_POS2D) / _RES 2D Normalized Position (vUV.st) _POS2DC _POS2D - vec2(_RES/2) 2D Centered Position in Pixels _POS2DNC (vec2(_POS2D) / _RES - _CENTER) 2D Normalized + Centered Position _POS2DNR _POS2DN * _RATIO2D 2D Normalized + Ratio Position _POS2DNCR (vec2(_RATIO2D) * vec2(_POS2DN - _CENTER)) 2D Normalized + Centered + Ratio Position _POS3DN vec3(_POS3D) / vec3(_RES.x,_RES.y,_DEPTH) 3D Normalized Position (vUV.stp) _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 _POS3D - vec3(vec2(_RES/2), _DEPTH/2) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN - _CENTER \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN * vec3(_RATIO2D, 1/_DEPTH) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 ( vec3(_RATIO2D, 1/_DEPTH) * (_POS3DN - _CENTER)) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized Position (vUV.st) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered + Ratio Position \u00a0 _P \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized Position (vUV.stp) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position \u00a0 iChannel[0-3]\u00a0 \u00a0 sTD2DInputs[0-3] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-3 (Alias for ShaderToy inputs) example : iChannel0 to access first 2D Input o[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mTDComputeOutputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Output Buffer 0-7 example : (o0 to access first buffer) i[0-7]_2D \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1_2D to access second 2D input) i[0-7]_3D \u00a0 \u00a0 \u00a0 sTD3DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Input Channel 0-7 example : (i1_3D to access second 3D input) i[0-7]_Array \u00a0 sTD2DArrayInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Array Input Channel 0-7 example : (i3_Array to access fourth 2D Array input) i[0-7]_Cube \u00a0 sTDCubeInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Cube Input Channel 0-7 example : (i3_Cube to access fourth Cube input) i[0-7] \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1 to access second 2D input) fragCoord \u00a0 \u00a0 \u00a0 _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels"},{"location":"en/Macros/#accessible-function-macros-in-pixel-wrangle","title":"Accessible Function Macros in Pixel Wrangle","text":"Macro name Macro value Comment fetch \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texelFetch(IN, POS, LOD) fetch(sampler*D IN, ivec* POS, int LOD OR int SAMPLE) =&gt; vec* tx \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texture(IN, POS, BIAS) tx(sampler*D IN, vec* POS, float OR vec* OR float[] bias) =&gt; float OR vec4 store \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 imageStore(OUT, POS, VALUE) store(gimage*D OUT, vec* POS, vec* VALUE) =&gt; void (image) td \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 TDOutputSwizzle(COLOR) td(vec4 COLOR) =&gt; vec4"},{"location":"en/Parameters/","title":"Parameters","text":"<p>Pixel-Wrangle provides many parameters divided into several pages.</p> <p>Each of the pages manages different aspects of Pixel Wrangle. Modifications made are saved with your presets. It is possible to make modifications through the Component Editor but I strongly advise against it, for the sake of compatibility with future versions of Pixel Wrangle</p> <p>Here is a general overview:</p> <ul> <li> <p>The 'Controls' page: These are all the parameters related to the variables you have declared in the 'Inputs' panel. These parameters are added dynamically based on your shader. You can also make modifications from the Pixel Wrangle instance's 'Component Editor' if you wish, although it is best to do so explicitly in the 'Inputs' panel via properties.</p> </li> <li> <p>The 'Code' page: This is where you can adjust the main features specific to Pixel Wrangle such as paths to the main library, to Visual Studio Code, UI appearance-related parameters, etc.</p> </li> <li> <p>The 'Inputs' page: You define the shader's inputs here such as their name, different modes (Direct, Feedback, Custom), and other options related to your shader's inputs</p> </li> <li> <p>The 'Outputs' page: This is where you define the shader's outputs, their name, etc.</p> </li> <li> <p>The 'GLSL' page: Parameters related to the underlying GLSL TOP. Such as the mode, GLSL version, etc.</p> </li> <li> <p>The 'Globals' page: Global parameters of the shader, such as output resolution, bit depth, etc.</p> </li> </ul>"},{"location":"en/Parameters/#controls-page","title":"Controls page","text":"<p>As mentioned previously, the 'Controls' page represents all variable declarations made in the 'Inputs' panel. You can modify the form of this control panel and each of the parameters through properties added as comments in your declarations (such as min, max, default, etc.) If you want to use the Component Editor to make changes to a parameter, you can, but generally I do not recommend it for the sake of portability of your presets in future versions of Pixel Wrangle. It is also worth noting that any changes made by the Component Editor will be overwritten if you subsequently modify the properties of this parameter in the Inputs panel. You will find here some examples for adding parameters to the page through the 'Inputs' panel.</p>"},{"location":"en/Parameters/#page-code","title":"Page Code","text":"<p>The Code page contains all options related to Pixel Wrangle, here is the list of available parameters:</p> Parameter Label Description Help Open online help Presets Folder Path to the Presets folder Update Folders Force update of the Presets folders content Open Presets Folder Open the Presets folder with the file explorer of your system, [CTRL] + O Open Functions Folder Open the Functions folder with the file explorer of your system, [CTRL] + [SHIFT] + O Compile Mode Lazy: recompile the shader when the focus of the code editor panel is lost, Continuous: recompile after each modification Word Wrap Automatically fold code over multiple lines when it exceeds the panel size Code Font Set the font used for the code UI Font Set the font used for the UI Font Size Adjust the global font size Line height Set the line height Main Color Set the main background color Disable UI Completely disable the UI Open as Perform Open the window in Perform mode (without the Touchdesigner UI), [F1] to open, [ESC] to close Open as Separate Open the window in Separate mode (the Touchdesigner UI remains accessible), [CTRL] + [ENTER] to open, [ESC] to close Set as Perform Set the Pixel Wrangle instance as the default window in Perform mode, [CTRL] + [F1] to activate Window Placement Dialog Open the Touchdesigner Perform windows management panel Close Close active windows of the Pixel Wrangle instance Library Path Pixel Wrangle root folder Rebuild Libs Runs the parsing script on the Function libraries located in \\/Functions/src to make them compatible with Touchdesigner Update Imported Libs Imports compatible libraries to the root of the current project in a baseCOMP located at path /libs"},{"location":"en/Parameters/#inputs-page","title":"Inputs page","text":"<p>The 'Inputs' page includes all parameters related to shader inputs.</p> <p>Below is a complete list of available parameters:</p> Parameter Label Description Play Enable time dependency (cook every frame) Run independently Make time independent from global start-stop Panel Source Select reference panel for mouse interactions Panel CHOP If Panel Source is 'Custom', reference the PanelCOMP used for mouse interactions Smooth Mouse Enable lag on mouse movements to smooth pointer trajectories Lag Specify smoothing in seconds for mouse lag Reset All Reset all inputs that are in 'Feedback' mode Active Enable corresponding shader input Name Name of input (displayed on hover) Color Set color of corresponding input Type Direct: Direct connection of an OP to the input, Feedback: Retrieve signal from one of the shader outputs (previous frame), Custom: Custom TOP Fallback TOP used when input is not connected or not compliant TOP If Type is 'Custom', Path of TOP to use for corresponding input Reset If Type is 'Feedback', Resets corresponding input Feedback Source If Type is 'Feedback', Selects selected shader output Feedback Init Type If Type is 'Feedback', select the initialization signal type Feedback Init Output If Type is 'Feedback' and Feedback Init Type is 'Output', use the selected shader output as initialization signal Feedback Init Built-in If Type is 'Feedback' and Feedback Init Type is 'Built-in', use the selected built-in as initialization signal Feedback Init Built-in If Type is 'Feedback' and Feedback Init Type is 'Custom', use the indicated TOP as initialization signal"},{"location":"en/Parameters/#page-outputs","title":"Page Outputs","text":"<p>The 'Outputs' page groups all parameters related to the shader inputs.</p> <p>Below you will find the complete list of available parameters:</p> Parameter Label Description Active Activates the corresponding shader input Name Name of the input (displayed when hovering over the input) Color Set the color of the corresponding input"},{"location":"en/Parameters/#page-glsl","title":"Page GLSL","text":"<p>The GLSL page groups all the parameters available on the GLSL page of a GLSL TOP. The easiest is to refer to the Touchdesigner documentation which will provide a complete list of adjustable options. The only parameter that differs is 'Local Size' available in 'Compute' mode. It defines the thread size (the number of pixels simultaneously sent to the GPU for processing by the shader). Usually this parameter is declared in code in the shader, but here you can define it in a TD parameter directly.</p>"},{"location":"en/Parameters/#page-globals","title":"Page Globals","text":"<p>The Global page defines global parameters for Pixel Wrangle, such as resolution, aspect ratio, etc. These parameters correspond to those that you might find on any TOP (on the Common page) in Touchdesigner. You can refer to the documentation of a GLSL TOP for more information.</p>"},{"location":"en/Presets/","title":"Presets","text":""},{"location":"en/Presets/#generalities","title":"Generalities","text":"<p>Pixel Wrangle has a system for managing presets.</p> <p>A Pixel-Wrangle preset contains both all the code you have written in each of the shader panels, as well as all the parameters and their state at the time of saving.</p> <p>To make it easier to load and filter presets, Pixel Wrangle provides a basic explorer with a file / folder hierarchy that reflects the structure of your file system</p> <p>The explorer allows you to find, load or save presets.</p> <p>It can be activated by clicking on the search area located at the bottom left of the interface or via the shortcut [CTRL] + Tab.</p> <p>You can then type in the name of your search to filter the results or scroll through the architecture.</p>"},{"location":"en/Presets/#important-paths","title":"Important paths","text":"<p>Presets are stored by default in the Presets folder at the root of Pixel Wrangle in your Palette.  </p> <p>There are 2 main roots:</p> <ul> <li>Factory library (\\/Presets) : This is the folder of presets that are shipped with Pixel Wrangle (Read-only) <li>User library (USER/Presets): This is the folder where your presets are saved, open this folder with the folder icon at the bottom left corner of Pixel Wrangle UI or CTRL + O</li> <p>All the created subfolders are reflected in the Pixel Wrangle preset browser.</p>"},{"location":"en/Presets/#load-a-preset","title":"Load a preset","text":"<p>To load a preset, simply double-click or press enter</p> <p>Warning, sometimes loading can be erratic, you may have to double-click several times. This is a known bug that should be fixed in upcoming versions of Pixel Wrangle</p>"},{"location":"en/Presets/#save-a-preset","title":"Save a preset","text":"<p>To save the state of your shader in a new preset, you can click on '+' in the UI. This will open a pop-up that will ask you under what name you want to save this preset. By default, this preset will be saved in the USER/Presets folder.</p> <p>You can also use path based naming schemes :</p> <ul> <li>gen/noise/mycrazynoise will save a preset called 'mycrazynoise.json' and create all the intermediates folder from the path selected in the left side. If nothing is selected, it will start from the USER/Presets (root)</li> </ul>"}]}