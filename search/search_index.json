{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pixel Wrangle Documentation","text":""},{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#2023-01-initial-release-version","title":"2023-01 -&gt; Initial release version","text":"<p>Since this is a first release, it may not be free of bugs. Using it within your projects is at your own risk. [!BUG]</p> <ul> <li> <p>Loading presets still buggy, you have to double click multiple times to load preset properly [!Main FEATURES]</p> </li> <li> <p>Compute shaders, 2D array buffers and 3D are all supported</p> </li> <li>All GLSL TOP parameter types are now supported + all other parameter types with specific syntax, see Coding with Pixel Wrangle page for syntax examples</li> <li>All parameter properties are available for customizing appearance, see Parameters page for full list</li> <li>Export your shader in a new PanelCOMP in one-click (Removing Pixel Wrangle dependency)</li> <li>UI has been completely rebuild (you can now customize the main background color, text size, text font, text line height), see UI overview page</li> <li>Built-in mouse interactions are available everywhere while hovering a viewer and holding [CTRL] key</li> <li>A bunch of macros are added for the most common operations, see Macros page</li> <li>Add fuzzy search (and path based) to find relevant functions and presets</li> <li>External library auto-parser to use arbitrary pure GLSL library, for td specific path resolving and conversion of old GLSL syntaxes, see Functions</li> <li>Ability to save your own functions / snippets to build your custom GLSL library</li> <li>Function loader has preview hints (doc header and signatures)</li> <li>Updated keyboard shortcuts, the full list is available in Keyboard Shortcuts</li> <li>Non-default parameters are now always saved with preset (including resolution, bit depth, shader mode, etc...)</li> </ul>"},{"location":"en/","title":"Index","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/","title":"Coding with Pixel-Wrangle","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#introduction","title":"Introduction","text":"<p>Pixel Wrangle offers a pixel shader development environment involving an underlying GLSL TOP. It therefore uses the GLSL language because it inherits from GLSL TOP. GLSL TOP is a GLSL implementation offered by Touchdesigner in its own ecosystem, it fits into the workflow of TOPs (Texture Operators in the Touchdesigner terminology). For more information on the GLSL language, visit the GLSL page. For more information on TOPs in Touchdesigner, go here.</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#overview-of-the-pixel-wrangle-editor","title":"Overview of the Pixel Wrangle editor","text":"<p>Editing code in Pixel Wrangle is divided into 3 tabs in the en/index:</p> <ul> <li>The IO tab which contains the 'Inputs' (your 'uniform' variables) and 'Outputs' (the shader's output buffers) panels. These panels have specific syntax which is detailed further -&gt; Coding with Pixel Wrangle</li> <li>The Functions tab which houses all the code outside the main() function. You can declare your custom functions, macros, shared variables, etc. there.</li> <li>The Main tab which corresponds to the body of the main() function. You do not need to declare this function within your code, just write your code as you would in the main() function.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#execution-order","title":"Execution order","text":"<p>The code content of the 3 tabs is parsed, then sent to the compiler in the following order:</p> <ol> <li>Macros</li> <li>IO -&gt; Inputs (uniform)</li> <li>Functions -&gt; imports with #include + function declarations</li> <li>IO -&gt; Outputs (Buffers)</li> <li>Main (main() function with your code inside)</li> </ol> <p>To view the complete code (once parsed: that is, as it is sent to the compiler), you can consult the 'Full Code Panel' ([CTRL] + 9)</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#attention","title":"Attention","text":"<ul> <li>Both the 'Functions' and 'Main' tabs use standard GLSL syntax, so you can write code exactly as you would in any GLSL shader.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#but","title":"BUT","text":"<ul> <li>The 'IO' tab has a special syntax, explained in detail below</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#io-tab-specifics","title":"IO tab specifics","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#inputs-panel-uniform-variables","title":"Inputs panel (uniform variables)","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#syntax-specifics","title":"Syntax specifics","text":"<ul> <li>Each of the variables you declare in the Inputs panel are uniform variables mapped to a Touchdesigner parameter.</li> <li>No 'uniform' keyword, it is implicit and is added automatically when parsing by Pixel Wrangle, before compilation.</li> <li>Your uniform variable name reflects the name of the associated Touchdesigner parameter.</li> <li>Consequently, your variable name must absolutely start with a capital followed by lowercase letters only, and NO special characters or '_' (constraint of Touchdesigner parameter names)</li> <li>The type of the variable determines the type of the Touchdesigner parameter that will be associated with it, following the same scheme as your uniforms declarations in a GLSL TOP</li> <li>**Any line of code starting with '//' or '/*' is considered a comment, EXCEPT Specific cases (Headers)</li> <li>**Any variable declaration or comment must be made on a single line.</li> <li>**To customize the Touchdesigner parameter associated with your uniform variable, you can add a comment after the declaration of your variable followed by pairs of property=value detailed here</li> <li>Modifiable properties reflect what you could do via the Component Editor, no more.</li> <li>**Each property must be followed by a '=' sign then its value.</li> <li>**Each [property=value] pair must be separated by a ';'</li> <li>The list of modifiable properties is available below, in the 'Modifiable properties' section</li> <li>Properties whose value is a string must not be enclosed in ' or \", but written directly as they are.</li> <li>However, properties whose value is an array of string must be written in the form [ 'Menu Entry 1' , 'Menu Entry 2' ]\\ with ' or \" enclosing each element of the array.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#specific-cases-headers","title":"Specific cases (Headers)","text":"<ul> <li> <p>Header type parameters are available although they have no meaning at the GLSL level, as they are useful for formatting the UI.</p> </li> <li> <p>The syntax for creating a Header type parameter is '//--- '.</p> </li> <li>You can then associate a label and/or section property with it.</li> </ul> <p>For example: '//--- label=Noise Types; section=1' will create an UI parameter of type Header, with the title: 'Noise Types', and will have a separator above it.</p> <ul> <li>Other parameters not compatible as 'uniform' with GLSL TOP such as 'File' or 'Folder' types are not available through the IO panel.</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#correspondence-of-glsl-types-td-parameter-styles","title":"Correspondence of GLSL Types / TD parameter styles","text":"GLSL Type TD Parameter Style Syntax int Int OR Menu OR Toggle OR Pulse int Newint; float Float float Newfloat; vec[2-4] Float of size [2-4] OR Color for vec[3-4] vec3 Newcolor; uvec[2-4] Int of size [2-4] OR Color for vec[3-4] uvec2 Newunsignedvec; ivec[2-4] Int of size [2-4] OR Color for vec[3-4] ivec2 Newsignedvec; bvec[2-4] Int of size [2-4] OR Color for vec[3-4] bvec2 Newboolvec; \\&lt;TYPE&gt;[*] CHOP vec4 Newvectorarray[16] =&gt; !! Array of 16 vec4 values, needs to be referenced by a CHOP that holds the corresponding channels !! mat4 CHOP mat4 Newmatrix; atomic_uint Int atomic_uint Newatomicint; const int Int OR Menu OR Toggle OR Pulse const int Newconstantint = 0;"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#modifiable-properties","title":"Modifiable properties","text":"Syntax Description Default Value label Parameter Label Parameter Name section Parameter has separator 0 order Parameter UI order (position) integer =&gt; Same as your declaration order readonly Parameter Lock 0 enable Parameter Activation 1 enableExpr Parameter Activation Expression '' help Parameter Help text on hover '' style Parameter Style Float or Color (for vec3-4) or Str or CHOP (according to variable type). Can be modified for int, float, vec3-4 (Valid values =&gt; Menu, Color, Toggle, Pulse, Float, Int) expr Parameter Expression '' bindExpr Parameter Bind Expression '' menu Parameter Menu entries (integer type only) '' default Parameter Default Value 0 or '' min Minimum Parameter Value 0 max Maximum Parameter Value 1 toggle Parameter is a toggle (integer type only) '' pulse Parameter is a Pulse (integer type only) '' chop Parameter chop path (mat4 type only) ''"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#examples","title":"Examples","text":"<pre><code>/* Syntax example */\n// Single line comments are ignored by the parser\n// Except for header (when line start with //---)\n//--- label=Simple Parameters; section=1\n// Create Float Parameter\nfloat Float; // default=0; min=-1; max=1; section=1\n// Create Integer Parameter\nint Int;     // min=-10; max=10; default=0\n//--- label=Vector Parameters; section=1\n// Create Color Vector Parameter\nvec3 Color;  // default=[0, 0.7, 1]; section=1\n// Create Vector style Parameter\nvec3 Position;  // default=[0, 0.7, 1]; style=Float\n//--- label=Menu Parameters; section=1\n// Create Menu Parameter\nint Newmenu;                  // menu=['Tomatoes', 'Bananas']; default=1; section=1\n//--- label=Array Parameters; section=1\n//// Create a uniform array of vec2 (you will need to specify a CHOP target with 2 channels and 16 samples each)\n// vec2 Array[16];\n//// Create a texture buffer array of vec4 (you will need to specify a CHOP target with 4 channels and 200 samples each)\n// vec4 Array[200];\n//// Create Matrix Parameter (you will need to specify a compatible 'chop' like transformCHOP to remove warning)\n// mat4 NewMatrix;\n/* Vulkan Specialization Constants */\nconst int ConstanttypeMenu = 0;     // menu=['Candies', 'Sky']; label=Vulkan Constant Menu\n//--- label=Atomic Counters; section=1\n// Create Atomic Counter\natomic_uint NewAtomicCounter; // section=1\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#outputs-panel-buffers","title":"Outputs panel (Buffers)","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#generalities-within-glsl-top","title":"Generalities within GLSL TOP","text":"<p>Buffers are variables that allow storing and sharing data between different shaders or different rendering stages. They are useful for accumulating data and communicating between the different shaders of a rendering pipeline.</p> <p>Here are the 2 most used forms within the Touchdesigner GLSL TOP:</p> <ul> <li> <p>Texture buffers (Accessible in Vertex/Pixel AND Compute mode): They allow referencing textures that will be used for display. They are generally used in shaders to READ texture pixels and use them to influence the final color of the pixel.</p> </li> <li> <p>Image buffers (Accessible in Compute mode ONLY): They allow READING AND WRITING to image data buffers such as textures or offscreen renderings. They are generally used in shaders to perform image processing operations.</p> </li> </ul> <p>It is also possible to declare image texture buffers with dimensions greater than 2 (for example, a 3D texture or a 3D image).</p> <p>It is important to note that texture buffers and image buffers cannot be used interchangeably. Each has its own syntax and its own access functions.</p> <p>Also, it should be noted that image buffers can be accessible for reading and writing but only in 'Compute Shader' mode, refer to the Pixel Wrangle or GLSL TOP parameters page to adjust this option (Output Access).</p> <p>Regarding texture buffers: they are accessible in READ ONLY mode but available in both modes (Vertex/Pixel AND Compute)** with the texture() function.</p> <p>Furthermore, within a Pixel Shader in 'Compute' mode, the use of texelFetch() is more appropriate for reading texture data as it generally offers better performance while allowing the management of mipmap levels (or LOD =&gt; Level Of Detail).</p>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#examples-in-a-glsl-top","title":"Examples in a GLSL TOP","text":""},{"location":"en/Coding%20with%20Pixel%20Wrangle/#vertexpixel-mode","title":"Vertex/Pixel Mode","text":"<pre><code>// Declare a buffer in Pixel/Vertex mode\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec4 otherColor;\nlayout(location = 2) out vec4 extraInfo;\nvoid main(){\n/* Assign a value to a buffer */\n// Write the red color to the 'fragColor' buffer\nfragColor = vec4(1,0,0,1); // Buffer 0 = Red\n// Write the color of the first 2D input, sampled with the normalized vUV.st coordinates provided by Touchdesigner.\notherColor = texture(sTD2DInputs[0], vUV.st); // Buffer 1 = Texture of the first input\n// Write the blue color to the 'fragColor' buffer\nextraInfo = vec4(0,0,1,1); // Buffer 2 = Blue\n}\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#compute-mode","title":"Compute Mode","text":"<pre><code>/*\nCompute shaders do not have an opinion on the type of data you provide them with, or on how to distribute calculations across the GPU. These aspects offer great flexibility but require determining in advance how you want calculations to be performed on your graphics card.\nFor more information on this, you can refer to the official GLSL documentation. For a brief explanation of the concept and its implementation in TD, visit https://docs.derivative.ca/Compute_Shader and https://docs.derivative.ca/Write_a_GLSL_TOP\n*/\n// Declare the size of the thread groups\nlayout (local_size_x = 8, local_size_y = 8) in;\n/*\nThe group size is used to determine how texture data is partitioned and distributed to threads on your GPU.\nFor example, if you use a 512 x 512 pixel texture and a group size of 8 x 8, you will need 64 thread groups to cover the entire texture.\nIf you leave the Auto-dispatch parameter on ON in the GLSL page settings, GLSL TOP will automatically assign the number of necessary groups to cover the full resolution chosen, so here: 64. (512/8 for each dimension).\nIn the other case, you will need to manually set the number of thread groups using the Dispatch Size parameter.\n*/\nvoid main(){\n// Define the color\nvec4 color = vec4(1,0,0,1); // Buffer 0 = Rouge\n// Write red color in Buffer 0\nimageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), color);\n}\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#managing-buffers-with-pixel-wrangle","title":"Managing buffers with Pixel Wrangle","text":"<ul> <li>Declare your buffers directly in the 'Outputs' panel of the 'IO' tab, in the same way, whether you are in Vertex/Pixel mode or Compute mode. In general (although there is no absolute rule), I recommend using CAPITAL NAMES to clearly differentiate your output buffers from your Inputs. Below is an example of declaring 3 output buffers</li> </ul> <pre><code>vec4 IMAGE;\nvec4 POSITION;\nvec4 NORMALS;\n</code></pre> <ul> <li> <p>Declare your buffers directly in the 'Outputs' panel of the 'IO' tab, always in the same way, whether you are in Vertex/Pixel mode or in Compute mode. In general (although there is no absolute rule), I recommend using names in CAPITALS to clearly differentiate your output buffers from your Inputs. Below is an example of declaring 3 output buffers.</p> </li> <li> <p>Pixel Wrangle creates the necessary outputs immediately with their respective names, you will see them appear on the OP instance as TOP type outputs.</p> </li> <li> <p>At the same time, a tab corresponding to each of your declarations will be visible in the 'Viewer' panels.</p> </li> <li> <p>Outputs are mapped in the order in which they were declared. If you want to change this order, you can change the order of your declarations.</p> </li> <li> <p>By default, each of these declarations dynamically adds a corresponding macro to easily access them in Compute Shaders. To take the previous example, this is what it looks like in the code sent to the compiler:</p> </li> </ul> <pre><code>#define IMAGE mTDComputeOutputs[0]\n#define POSITION mTDComputeOutputs[1]\n#define NORMALS mTDComputeOutputs[2]\n</code></pre> <ul> <li>Then, you can write to these buffers as follows from the 'Main' tab:</li> </ul>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#vertexpixel-mode_1","title":"Vertex/Pixel Mode","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shorthand for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1);\n/* Write vec4 'c' in 'IMAGE' Buffer, td() is a shorthand for TDOutputSwizzle() */\nIMAGE = td(c)\n/*\nTo learn more about the macros used above, you can go to the [Macros](../fr/Macros.md) page, where you will find a complete list of macros that can be used in Pixel Wrangle. They can also be viewed from the 'Macros' panel in the upper left of the interface, or directly from the 'Full Code' panel as they are sent to the compiler.\n*/\n</code></pre>"},{"location":"en/Coding%20with%20Pixel%20Wrangle/#compute-mode_1","title":"Compute Mode","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shortcut for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1);\n/* Write vec4 'c' in 'IMAGE' Buffer using Absolute Coordinates */\n// Shortcut for imageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), TDOutputSwizzle(c))\nstore(IMAGE, _UV, td(c));\n</code></pre>"},{"location":"en/Contribute/","title":"Contribute","text":"<p>I want to emphasize that I do not invite anyone to use Pixel Wrangle in productions that require stability above all else at this time.</p> <p>This project is in its early stages, so it is very likely that you will encounter bugs and that breaking changes will occur in the first iterations.</p> <p>Any RFE is obviously welcome via the dedicated section on the GitHub repo. However, I cannot guarantee flawless responsiveness at this time in terms of bug fixes and the implementation of new features (but I will do my best).</p> <p>On the other hand, if anyone is interested in helping me make this project a reality, I would be delighted to exchange and collaborate on this topic. Despite the fact that TD .tox are binaries, it is still possible to load scripts from the outside, so finally quite a few things are externalizable (including the most awkward Python scripts to date).</p> <p>Available to exchange, preferably via GitHub, or by email at the following address: studio.miu.lab@gmail.com</p>"},{"location":"en/Functions/","title":"Functions","text":""},{"location":"en/Functions/#external-libraries","title":"External libraries","text":""},{"location":"en/Functions/#introduction","title":"Introduction","text":"<p>Pixel Wrangle is designed as a modular environment.</p> <p>It is therefore possible to extend the available functions through existing GLSL libraries, or by building your own libraries by saving functionality that you can then recall in all your projects.</p> <p>This can be useful when you want to reuse code more granularly than you could with presets.</p> <p>Note also that when you import external libraries, they become available throughout your entire project, which means that you can fully reference these imports in a bare GLSL TOP, regardless of the use of Pixel Wrangle.</p>"},{"location":"en/Functions/#lygia","title":"Lygia","text":"<p>By default, Pixel Wrangle provides a very complete granular function library called Lygia.</p> <p>Lygia is a community project led by Patricio Gonzalez Vivo, who is also behind  https://thebookofshaders.com, an introduction to fragment shaders.</p> <p>For more information on this library and its content, you can also consult the Official GitHub</p>"},{"location":"en/Functions/#important-files-and-folders","title":"Important files and folders","text":"<p>Files related to external libraries are stored in the Functions folder at the root of the Pixel Wrangle project.</p> <p>To add an external library of your choice, you can clone its content into the Functions/src/\\ folder. <p></p> <p>In the following sections, you will see how to integrate these libraries into your projects.</p> <p>I also specify that for the library to be readable by Pixel Wrangle, the files must have a '.glsl' extension, any other type of file will be ignored.</p>"},{"location":"en/Functions/#auto-parsing","title":"Auto-parsing","text":"<p>Pixel Wrangle provides a summary parsing tool that makes pure GLSL libraries, GLSL libraries compatible with the Touchdesigner ecosystem.</p> <p>This mainly concerns the form of the import paths that are specific to Touchdesigner, but also the conversion of certain function names such as texture2D(), and others so that the library runs correctly in the Touchdesigner environment.</p> <p>The principle is as follows:</p> <p>You drop your raw library folders in the Functions/src folder as described above You parse your libraries directly from the Pixel Wrangle interface (Just press 'Build Libraries' from the 'Code/Plugin' page) Once the libraries are parsed, an automatically Touchdesigner-compatible copy of the file / folder architecture is made in the 'Functions/dist' folder.</p>"},{"location":"en/Functions/#importing-libraries-in-the-project","title":"Importing Libraries in the Project","text":"<p>To import libraries into your project, simply press 'Import Libraries' from the 'Code/Plugin' page. This will create the entire file/folder architecture at the root of your TouchDesigner project, in a BaseCOMP called 'libs'.</p> <p>Each '.glsl' import is actually a TextDAT in Sync File mode, which points to the corresponding file in the Functions/dist folder (the copy of the file after parsing).</p> <p>Since the library architecture is integrated into the root of your project, you can reuse all functions in a GLSL TOP context without going through the Pixel Wrangle envelope.</p>"},{"location":"en/Functions/#including-functions-in-your-pixel-wrangle-instance","title":"Including Functions in Your Pixel Wrangle Instance","text":"<p>By pressing the shortcut [CTRL] + [SHIFT] + [TAB], or clicking in the search bar at the bottom right of the interface, you can access the function explorer. This explorer returns a list of all functions available within your project. You can then search by typing a keyword, the list is automatically filtered.</p> <p>Pixel Wrangle will also provide header documentation for all your functions, as well as all the signatures that you can copy and paste directly into your code.</p> <p>Finally, you can double-click on the function in the list, which will import it into your Pixel Wrangle instance. You can see the inclusion appear in your 'Functions' panel.</p>"},{"location":"en/Functions/#adding-your-own-functions","title":"Adding your own functions","text":"<p>If you want to add new functions as you use Pixel Wrangle, you can do so using the '+' function in the Functions panel.</p> <p>You will then be asked for the name of the file to save as well as a header comment to provide useful information about the role of the file and its functions.</p> <p>By default, these presets are saved to the root of your Functions/user folder in a '.glsl' file. You can then place them in the directories of your choice and define the hierarchy of your choice in your project.</p>"},{"location":"en/Functions/#organize-your-functions-into-a-useful-library","title":"Organize your functions into a useful library","text":"<p>There is no particular method for creating your own GLSL function libraries, but some recommendations:</p> <ul> <li>Try to avoid creating dependencies on functions from other libraries to preserve portability of your library in different contexts</li> <li>As much as possible, try to organize your function files granularly and adopt a hierarchy by utility / context for clarity</li> <li>With the exception of overloading functions or declaring variations of signatures for the same function, it is recommended to have only one functionality per file.</li> </ul>"},{"location":"en/GLSL%20Language/","title":"GLSL Language","text":""},{"location":"en/GLSL%20Language/#generalities","title":"Generalities","text":"<p>GLSL is a compiled C-type language designed to create shaders. It was created and is maintained by the non-profit consortium Khronos Group, which is behind the open-source OpenGL standard (and now Vulkan, which will eventually replace OpenGL).</p> <p>A shader is a small computer program limited to a specific task. It is generally used to display things on the screen. GLSL shaders are run on your graphics processor (GPU).</p> <p>GLSL is able to intervene at several levels of the image rendering process. All the steps necessary to provide the final result are called the GLSL Language#Rendering Pipeline. Therefore, GLSL integrates into graphics applications using the OpenGL, Vulkan, WebGL APIs, and more.</p> <p>As of the 2022 builds, Touchdesigner integrates GLSL through Vulkan, the latest graphics API from Khronos, which will eventually replace OpenGL.</p> <p>The software provides an implementation of GLSL through two of its native operators: GLSL TOP (Texture) and GLSL MAT (Materials).</p> <p>It is important to note that GLSL shaders run in parallel on your machine, taking advantage of the power of graphics processors (GPUs) and offering very good performance for real-time applications.</p> <p>However, some programming basics are necessary to fully exploit the potential of shaders or adapt them to your own needs. In addition, programming a GPU (parallel calculation) requires a particular code structure and some constraints that may take some time to be understood.</p> <p>I highly recommend reading the excellent https://thebookofshaders.com, which helps to better understand these concepts, especially since much of the content is translated into many languages.</p> <p>Finally, GLSL is directly derived from the C language, so the syntax and semantics are very similar.</p> <p>However, there are some notable differences compared to C, including:</p> <ul> <li>A shortened syntax for manipulating vectors (called vector swizzling)</li> <li>A native library containing common mathematical functions as well as other functions specific to shaders</li> <li>Special types (matrices, samplers, etc.) dedicated to shader manipulation</li> <li>And many other things that I invite you to discover for yourself through the official documentation.</li> </ul> <p>You will also discover that some features of C are absent.</p> <p>For example, certain types such as strings do not exist in GLSL. This is partly due to the constraints imposed by the architecture of current GPUs and the way they perform calculations.</p> <p>Finally, you will find a list of useful links below for your journey.</p>"},{"location":"en/GLSL%20Language/#useful-links","title":"Useful Links","text":"<p>[!INFO]</p> <ul> <li> <p>An essential resource for getting started if you have never worked with shaders (The Book of Shaders).</p> </li> <li> <p>An overview of the language specifications in video.</p> </li> <li> <p>The official documentation of the language available on the Khronos website as a downloadable PDF.</p> </li> <li> <p>An index of functions included in the GLSL standard library.</p> </li> <li> <p>More details on the implementation of GLSL TOP (the underlying operator of Pixel Wrangle) in Touchdesigner.</p> </li> <li> <p>Shadertoy, a website that allows for the creation of shaders online using WebGL. It is a great place to find many examples of shaders created by the community.</p> </li> <li> <p>The website of Inigo Quiles is also a massive learning resource for understanding various mechanisms related to shader creation and the underlying math.</p> </li> <li> <p>Lygia is a community project led by Patricio Gonzalez Vivo (The Book of Shaders) among others, and is a library of GLSL (and HLSL) functions that provides a large number of very useful functions. It is natively provided with Pixel Wrangle and greatly facilitates work.</p> </li> <li> <p>Many YouTube videos cover shader creation. Some in the context of Touchdesigner, Unity, Shadron, glslsandbox, or other frameworks. The YouTube channel The Art Of Code, for example, offers a good introduction to GLSL on Shadertoy through practice.</p> </li> </ul>"},{"location":"en/GLSL%20Language/#rendering-pipeline","title":"Rendering Pipeline","text":"<p>GLSL is a language that can be used at different stages of the rendering pipeline.</p> <p>Each stage of the pipeline has its own variables and functions.</p> <p>Here is a list (non-exhaustive and probably inaccurate in some places) of the stages of the pipeline, in chronological order:</p> <ul> <li> <p>Vertex Specification: This is the initial stage, which involves retrieving the list of points and primitives and their attributes (ID, position, etc.) from CPU memory and converting them into a format that can be used in the subsequent stages of the rendering pipeline in GPU memory. This step is automatically performed by Touchdesigner and the OpenGL/Vulkan backend when using a GLSL TOP on a Geometry COMP.</p> </li> <li> <p>Vertex Shader: This is a program that operates at the level of the geometry of a 3D object, and is executed simultaneously on each vertex of the input geometry. It allows, in particular, to create and modify attributes such as the position of points to deform an object, for example. The result of these operations is then passed on to the next stage of the rendering pipeline. Some intermediate steps can be performed at this stage (see Geometry Shaders, Tessellation Shaders...).</p> </li> <li> <p>Rasterization: Rasterization is an operation that transforms a scene described in a 3D space into a 2D image that can be displayed on a screen at a chosen resolution (discretization). You can imagine this step as the projection of our screen space (the view) onto the 3D objects in the scene. This operation is automatically and transparently performed by the OpenGL/Vulkan backend. There is no associated shader that allows for control over this stage of the pipeline, but it is crucial in the rendering pipeline.</p> </li> <li> <p>Pixel Shader (or Fragment Shader): This is a program that runs on each pixel rendered on the screen. A pixel shader allows you to manipulate this data to produce the final color of the pixels.</p> </li> </ul> <p>-&gt; In the case of a 3D object from a vertex shader, the Pixel shader performs an interpolation of the attribute values provided by the vertex shader. You can then manipulate them as you wish to obtain the desired result</p> <p>-&gt; In the case where no Vertex Shader is provided. Touchdesigner's Pixel shader implementation (GLSL TOP) provides 2 rectangle triangles by default that form a rectangle with the exact dimensions of the screen. You therefore have a coordinate system from which you can have fun. Note that it is quite possible to create 3D images without using a vertex shader or a geometry composed of points. This means that all the logic must be coded in the pixel shader. Raymarching (or 'Sphere Tracing') is one of these techniques. It is based on the description of shapes by distance fields called SDFs. You can find a lot of examples on Shadertoy and Inigo Quiles's website if you want to learn more about these techniques. As for raymarching in Touchdesigner, the rayTK project led by tekt is a wonderful example of porting this technique to the Touchdesigner environment. It greatly simplifies its use through a pre-constructed operator ecosystem. A tip, go see it!</p> <p>In Touchdesigner, GLSL can be used through GLSL TOP (Image generation in the TOP context) or GLSL MAT (Material generation for 3D objects).</p> <p>NB: The work environment provided by Pixel Wrangle currently only works with GLSL TOP.</p>"},{"location":"en/GLSL%20Language/#pixel-shader","title":"Pixel Shader","text":"<p>In the case of a pixel shader without a manually associated vertex shader (the default behavior of Pixel Wrangle), the thing you are actually manipulating within the main() function of your shader is the current pixel.</p> <p>This pixel has an intrinsic and fundamental characteristic, its position in screen space. In the case of a 2D image, for example, this is the x and y coordinates.</p> <p>It is important to understand that this same program is executed simultaneously on each of the pixels that make up your final image.</p> <p>For an image of 1024 1024 pixels, for example, this program will be executed 1024 1024 times, a total of 1,048,576 times. That's a lot.</p> <p>In the case of a standard processor (CPU), all these executions would be carried out sequentially (or at best, distributed across the few cores of your CPU).</p> <p>A CPU is very efficient for most everyday tasks with a computer and has fast and significant memory storage (RAM), but it is not very efficient when you need to perform the same processing on a large number of elements at the same time, as is the case with an image made up of pixels.</p> <p>On the contrary, a shader runs on your graphics processor (GPU). GPUs have a different architecture than CPUs, which is designed to execute a large number of tasks at the same time. For comparison, a GPU has a few thousand cores to more than 10,000 for high-end GPUs. This greatly reduces the number of operations performed at the same time, as the calculations are distributed among the thousands of cores of your GPU.</p> <p>The main limitations of the GPU:</p> <ul> <li>Limited memory space (VRAM is expensive and of fixed size), which implies a certain size and complexity limit for operations, more easily reached than with a CPU.</li> <li>A lower sequential execution speed (per GPU core) than your CPU.</li> <li>Current GPUs perform calculations with numbers only, making them difficult to use for tasks that manipulate strings of characters or certain types of complex data that are common in traditional programming.</li> <li>Abstraction capabilities are reduced, the scope of operations is limited.</li> </ul>"},{"location":"en/GLSL%20Language/#gpu-vs-cpu-by-example","title":"GPU vs CPU by example","text":"<p>CPU :</p> <ul> <li>Write 2 nested for loops, each iterating over the x and y coordinates of the image.</li> <li>Execute your main() function with all your code inside the 2 loops, on each of the pixels composing your image.</li> </ul> <pre><code>int ResolutionX = 1024;\nint ResolutionY = 1024;\nfor(int x=0; x&lt;ResolutionX; x++){\nfor(int y=0; y&lt;ResolutionY; y++){\n/* Intrinsic Attributes */\nuvec2 absolutePositionOfCurrentPixel   = uvec2(x,y);                                                           // -&gt; Absolute Coordinates   (with x and y integer values between 0 and Resolution-1)\nvec2 normalizedPositionOfCurrentPixel =  vec2(float(x)/float(ResolutionX-1),float(y)/float(ResolutionY-1));   // -&gt; Normalized Coordinates (with x and y float values between 0 and 1) =&gt; vUV.st\n/* Your main() function in a 2D Pixel Shader is executed here */\n// Your awesome stuff...\n// ...\n}\n}\n</code></pre> <p>Pixel Shader (GPU) :</p> <ul> <li>The coordinates are already provided by the main context through a variable called vUV in Touchdesigner.</li> <li>Just write your code in the main() function and retrieve the coordinates directly from the shader (vUV). This would have the following form for an image of 1024 * 1024 pixels: Within the main() function of a pixel shader, you can consider that each of your instructions is executed simultaneously, and the execution context is the internal part of this double 'for' loop.</li> </ul> <p>GLSL and Vulkan intelligently distribute the simultaneous execution of the program on all available cores of your GPU.</p>"},{"location":"en/GLSL%20Language/#pixel-coordinates","title":"Pixel Coordinates","text":"<p>In Touchdesigner, the normalized x and y coordinates are provided to you in the form of a vector in your shader through a variable directly provided by the execution context.</p> <p>This is the variable vUV</p> <pre><code>vec2 coords = vUV.xy; // Will store a copy of current XY coord in 'coords' vec2 variable\n</code></pre>"},{"location":"en/Install/","title":"Install","text":""},{"location":"en/Install/#prerequisites","title":"Prerequisites","text":"<p>The only thing you definitely need to get started is a recent version of Touchdesigner (builds 2022.XX and later) installed on your machine.</p> <p>If you don't have a license, you can still use Touchdesigner with a 'NON-COMMERCIAL' license. These versions have the vast majority of features and are currently capable of running Pixel-Wrangle.</p> <p>Touchdesigner can be downloaded by following this link, it will give you an overview of the different license models.</p> <p>Optionally, you can download Git if you want to update future versions of Pixel Wrangle directly through your Terminal.</p> <p>Finally, if you want to take advantage of the documentation (in Markdown) in the best conditions, you can download Obsidian. You will have access to it independently of your internet connection with a nice interface.</p>"},{"location":"en/Install/#downloading-the-project","title":"Downloading the Project","text":"<p>Once Touchdesigner is installed,</p>"},{"location":"en/Install/#if-you-have-not-installed-git","title":"If you have not installed Git","text":"<ul> <li>Download the repository as a ZIP file from https://github.com/miu-lab/TD-Pixel-Wrangle by clicking on 'Download ZIP'</li> </ul>"},{"location":"en/Install/#installing-pixel-wrangle","title":"Installing Pixel Wrangle","text":""},{"location":"en/Install/#if-you-have-not-installed-git_1","title":"If you have not installed Git:","text":"<ul> <li> <p>Move the downloaded zip file to C:\\Users\\\\Documents\\Derivative\\Palette and extract its contents to this folder as shown below <li> <p>Attention, it is important that the root folder of the project has the exact name: TD-Pixel-Wrangle</p> </li> <p></p>"},{"location":"en/Install/#or-if-you-have-installed-git","title":"OR If you have installed Git","text":"<p>Launch a terminal in the folder C:\\Users\\\\Documents\\Derivative\\Palette or navigate there with cd and then do a 'git clone' of the project <pre><code>git clone https://github.com/miu-lab/TD-Pixel-Wrangle.git\n</code></pre>"},{"location":"en/Install/#configuration","title":"Configuration","text":"<p>If you wish to work with Visual Studio Code, you can immediately specify the path to the executable in the 'settings.json' file at the root of the project.</p> <pre><code>{\"vscodePath\": \"C:\\\\Users\\\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\Code.exe\"}\n</code></pre> <p>Pour plus de d\u00e9tails sur l'utilisation conjointe de Pixel Wrangle avec Visual Studio Code, rendez-vous sur la page Visual Studio Code</p>"},{"location":"en/Install/#documentation","title":"Documentation","text":"<p>Si vous souhaitez acc\u00e9der \u00e0 la documentation en local et dans les meilleures conditions comme \u00e9voqu\u00e9 plus t\u00f4t, vous pouvez t\u00e9l\u00e9charger Obsidian.</p> <p>You can then open a \"vault\" (vault: Obsidian terminology for designating a file and folder architecture in markdown).</p> <p>The documentation vault is stored in the 'doc' folder at the root of the project, you can open it directly in Obsidian Path: C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\Documents\\Derivative\\Palette\\TD-Pixel-Wrangle\\doc</p>"},{"location":"en/Install/#updating-the-touchdesigner-palette","title":"Updating the Touchdesigner Palette","text":"<p>After following these steps, it may be necessary to refresh the Touchdesigner Palette when launching Touchdesigner.</p> <p></p>"},{"location":"en/Keyboard%20Shortcuts/","title":"Keyboard Shortcuts","text":""},{"location":"en/Keyboard%20Shortcuts/#in-the-network-editor-with-the-pixel-wrangle-instance-as-the-current-op-green-borders","title":"In the Network Editor with the Pixel Wrangle instance as the 'Current OP' (Green Borders)","text":"Keyboard Shortcut Action [CTRL] + Enter Open Viewer in separate window for current selected Instance of Pixel Wrangle Escape Close Viewer for current selected Instance of Pixel Wrangle [CTRL] + F1 Set Perform window for current selected instance of Pixel Wrangle F1 Open Perform Window"},{"location":"en/Keyboard%20Shortcuts/#in-the-global-ui-window-of-the-current-instance","title":"In the global UI window of the current instance","text":"Keyboard Shortcut Action [CTRL] + 1 Switch to IO Tab [CTRL] + 2 Switch to Functions Tab [CTRL] + 3 Switch to Main Tab [CTRL] + 0 Toggle Full Screen Viewer [CTRL] + 9 Toggle Full Code Panel (Read-Only) [CTRL] + M Toggle Macros Panel (Read-Only) [CTRL] + T Toggle Time Dependency [CTRL] + P Toggle Parameter Panel [CTRL] + [SHIFT] + P Toggle Viewer in Parameter Panel [CTRL] + Tab Open Preset Loader Panel [CTRL] + [SHIFT] + Tab Open Functions Loader Panel"},{"location":"en/Keyboard%20Shortcuts/#in-main-tab","title":"In Main tab","text":"Keyboard Shortcut Action [CTRL] + [SHIFT] + 1 Toggle IO Tab in Main Tab on Left Side [CTRL] + [SHIFT] + 2 Toggle Functions Tab in Main Tab on Right Side"},{"location":"en/Keyboard%20Shortcuts/#in-a-viewer-panel","title":"In a Viewer panel","text":"<p>All shortcuts for TOPs are available in addition to the following:</p> Keyboard Shortcut Action [1-8] Switch Tab on corresponding Output Holding [CTRL] + Click Interaction Mode (Mouse Position, Mouse Clicks)"},{"location":"en/Macros/","title":"Macros","text":""},{"location":"en/Macros/#generalities","title":"Generalities","text":"<p>In GLSL, macros are instructions that allow for defining reusable code. They are similar to C macros and are defined using the <code>#define</code> directive. Macros can be useful for simplifying code and making it more readable, but it is important to be careful not to abuse them as they can make the code difficult to understand and debug. By definition, macro evaluation occurs at compile time (static), not at runtime. This means that they cannot be modified during the execution of the program, unlike uniform variables for example. Therefore, their use cases are different.</p> <p>Voici un exemple de d\u00e9finition de macro simple :</p> <pre><code>#define PI 3.14159265\n</code></pre> <p>In this case, each occurrence of <code>PI</code> in the code will be replaced with the value <code>3.14159265</code> during compilation.</p> <p>We can also define macros with more complex expressions, which act as functions with arguments for example:</p> <pre><code>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n</code></pre> <p>In this case, when the <code>MIN</code> macro is used in the code with arguments, it is replaced by the conditional expression that compares the two arguments and returns the smallest of the two. For example, the <code>MIN(x, y)</code> instruction will be replaced by <code>((x) &lt; (y) ? (x) : (y))</code>.</p>"},{"location":"en/Macros/#important-files","title":"Important files","text":"<p>You will find in the /Macros folder of the repo, the files containing all the macros pre-declared by Pixel Wrangle in your shaders. Feel free to add your own. The following table lists all the macros that Pixel Wrangle makes available to you.</p>"},{"location":"en/Macros/#accessible-variable-macros-in-pixel-wrangle","title":"Accessible Variable Macros in Pixel Wrangle","text":"Macro name Macro value Comment _PI 3.1415926535897932384626433832795 PI Value (3.14...) _TAU _PI * 2 2 * PI Value _GOLD 1.618033988749894 Golden Ratio _E 2.7182818284590452353602874713527 Euler Number _RES vec2(uTDOutputInfo.res.z,uTDOutputInfo.res.w) 2D Resolution in Pixels _DEPTH uTDOutputInfo.depth.y Depth _RATIO2D vec2(max(_RES.x/_RES.y, 1),max(_RES.y/_RES.x, 1)) Ratio from Max Axis _CENTER 0.5 Center _POS2DN vec2(_POS2D) / _RES 2D Normalized Position (vUV.st) _POS2DC _POS2D - vec2(_RES/2) 2D Centered Position in Pixels _POS2DNC (vec2(_POS2D) / _RES - _CENTER) 2D Normalized + Centered Position _POS2DNR _POS2DN * _RATIO2D 2D Normalized + Ratio Position _POS2DNCR (vec2(_RATIO2D) * vec2(_POS2DN - _CENTER)) 2D Normalized + Centered + Ratio Position _POS3DN vec3(_POS3D) / vec3(_RES.x,_RES.y,_DEPTH) 3D Normalized Position (vUV.stp) _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 _POS3D - vec3(vec2(_RES/2), _DEPTH/2) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN - _CENTER \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN * vec3(_RATIO2D, 1/_DEPTH) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 ( vec3(_RATIO2D, 1/_DEPTH) * (_POS3DN - _CENTER)) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized Position (vUV.st) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered + Ratio Position \u00a0 _P \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized Position (vUV.stp) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position \u00a0 iChannel[0-3]\u00a0 \u00a0 sTD2DInputs[0-3] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-3 (Alias for ShaderToy inputs) example : iChannel0 to access first 2D Input o[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mTDComputeOutputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Output Buffer 0-7 example : (o0 to access first buffer) i[0-7]_2D \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1_2D to access second 2D input) i[0-7]_3D \u00a0 \u00a0 \u00a0 sTD3DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Input Channel 0-7 example : (i1_3D to access second 3D input) i[0-7]_Array \u00a0 sTD2DArrayInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Array Input Channel 0-7 example : (i3_Array to access fourth 2D Array input) i[0-7]_Cube \u00a0 sTDCubeInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Cube Input Channel 0-7 example : (i3_Cube to access fourth Cube input) i[0-7] \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1 to access second 2D input) fragCoord \u00a0 \u00a0 \u00a0 _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels"},{"location":"en/Macros/#accessible-function-macros-in-pixel-wrangle","title":"Accessible Function Macros in Pixel Wrangle","text":"Macro name Macro value Comment fetch \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texelFetch(IN, POS, LOD) fetch(sampler*D IN, ivec* POS, int LOD OR int SAMPLE) =&gt; vec* tx \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texture(IN, POS, BIAS) tx(sampler*D IN, vec* POS, float OR vec* OR float[] bias) =&gt; float OR vec4 store \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 imageStore(OUT, POS, VALUE) store(gimage*D OUT, vec* POS, vec* VALUE) =&gt; void (image) td \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 TDOutputSwizzle(COLOR) td(vec4 COLOR) =&gt; vec4"},{"location":"en/Parameters/","title":"Parameters","text":"<p>Pixel-Wrangle provides many parameters divided into several pages.</p> <p>Each of the pages manages different aspects of Pixel Wrangle. Modifications made are saved with your presets. It is possible to make modifications through the Component Editor but I strongly advise against it, for the sake of compatibility with future versions of Pixel Wrangle</p> <p>Here is a general overview:</p> <ul> <li> <p>The 'Controls' page: These are all the parameters related to the variables you have declared in the 'Inputs' panel. These parameters are added dynamically based on your shader. You can also make modifications from the Pixel Wrangle instance's 'Component Editor' if you wish, although it is best to do so explicitly in the 'Inputs' panel via properties.</p> </li> <li> <p>The 'Code' page: This is where you can adjust the main features specific to Pixel Wrangle such as paths to the main library, to Visual Studio Code, UI appearance-related parameters, etc.</p> </li> <li> <p>The 'Inputs' page: You define the shader's inputs here such as their name, different modes (Direct, Feedback, Custom), and other options related to your shader's inputs</p> </li> <li> <p>The 'Outputs' page: This is where you define the shader's outputs, their name, etc.</p> </li> <li> <p>The 'GLSL' page: Parameters related to the underlying GLSL TOP. Such as the mode, GLSL version, etc.</p> </li> <li> <p>The 'Globals' page: Global parameters of the shader, such as output resolution, bit depth, etc.</p> </li> </ul>"},{"location":"en/Parameters/#controls-page","title":"Controls page","text":"<p>As mentioned previously, the 'Controls' page represents all variable declarations made in the 'Inputs' panel. You can modify the form of this control panel and each of the parameters through properties added as comments in your declarations (such as min, max, default, etc.) If you want to use the Component Editor to make changes to a parameter, you can, but generally I do not recommend it for the sake of portability of your presets in future versions of Pixel Wrangle. It is also worth noting that any changes made by the Component Editor will be overwritten if you subsequently modify the properties of this parameter in the Inputs panel. You will find here some examples for adding parameters to the page through the 'Inputs' panel.</p>"},{"location":"en/Parameters/#page-code","title":"Page Code","text":"<p>The Code page contains all options related to Pixel Wrangle, here is the list of available parameters:</p> Parameter Label Description Help Open online help Presets Folder Path to the Presets folder Update Folders Force update of the Presets folders content Open Presets Folder Open the Presets folder with the file explorer of your system, [CTRL] + O Open Functions Folder Open the Functions folder with the file explorer of your system, [CTRL] + [SHIFT] + O Compile Mode Lazy: recompile the shader when the focus of the code editor panel is lost, Continuous: recompile after each modification Word Wrap Automatically fold code over multiple lines when it exceeds the panel size Code Font Set the font used for the code UI Font Set the font used for the UI Font Size Adjust the global font size Line height Set the line height Main Color Set the main background color Disable UI Completely disable the UI Open as Perform Open the window in Perform mode (without the Touchdesigner UI), [F1] to open, [ESC] to close Open as Separate Open the window in Separate mode (the Touchdesigner UI remains accessible), [CTRL] + [ENTER] to open, [ESC] to close Set as Perform Set the Pixel Wrangle instance as the default window in Perform mode, [CTRL] + [F1] to activate Window Placement Dialog Open the Touchdesigner Perform windows management panel Close Close active windows of the Pixel Wrangle instance Library Path Pixel Wrangle root folder Rebuild Libs Runs the parsing script on the Function libraries located in \\/Functions/src to make them compatible with Touchdesigner Update Imported Libs Imports compatible libraries to the root of the current project in a baseCOMP located at path /libs"},{"location":"en/Parameters/#inputs-page","title":"Inputs page","text":"<p>The 'Inputs' page includes all parameters related to shader inputs.</p> <p>Below is a complete list of available parameters:</p> Parameter Label Description Play Enable time dependency (cook every frame) Run independently Make time independent from global start-stop Panel Source Select reference panel for mouse interactions Panel CHOP If Panel Source is 'Custom', reference the PanelCOMP used for mouse interactions Smooth Mouse Enable lag on mouse movements to smooth pointer trajectories Lag Specify smoothing in seconds for mouse lag Reset All Reset all inputs that are in 'Feedback' mode Active Enable corresponding shader input Name Name of input (displayed on hover) Color Set color of corresponding input Type Direct: Direct connection of an OP to the input, Feedback: Retrieve signal from one of the shader outputs (previous frame), Custom: Custom TOP Fallback TOP used when input is not connected or not compliant TOP If Type is 'Custom', Path of TOP to use for corresponding input Reset If Type is 'Feedback', Resets corresponding input Feedback Source If Type is 'Feedback', Selects selected shader output Feedback Init Type If Type is 'Feedback', select the initialization signal type Feedback Init Output If Type is 'Feedback' and Feedback Init Type is 'Output', use the selected shader output as initialization signal Feedback Init Built-in If Type is 'Feedback' and Feedback Init Type is 'Built-in', use the selected built-in as initialization signal Feedback Init Built-in If Type is 'Feedback' and Feedback Init Type is 'Custom', use the indicated TOP as initialization signal"},{"location":"en/Parameters/#page-outputs","title":"Page Outputs","text":"<p>The 'Outputs' page groups all parameters related to the shader inputs.</p> <p>Below you will find the complete list of available parameters:</p> Parameter Label Description Active Activates the corresponding shader input Name Name of the input (displayed when hovering over the input) Color Set the color of the corresponding input"},{"location":"en/Parameters/#page-glsl","title":"Page GLSL","text":"<p>The GLSL page groups all the parameters available on the GLSL page of a GLSL TOP. The easiest is to refer to the Touchdesigner documentation which will provide a complete list of adjustable options. The only parameter that differs is 'Local Size' available in 'Compute' mode. It defines the thread size (the number of pixels simultaneously sent to the GPU for processing by the shader). Usually this parameter is declared in code in the shader, but here you can define it in a TD parameter directly.</p>"},{"location":"en/Parameters/#page-globals","title":"Page Globals","text":"<p>The Global page defines global parameters for Pixel Wrangle, such as resolution, aspect ratio, etc. These parameters correspond to those that you might find on any TOP (on the Common page) in Touchdesigner. You can refer to the documentation of a GLSL TOP for more information.</p>"},{"location":"en/Presets/","title":"Presets","text":""},{"location":"en/Presets/#generalities","title":"Generalities","text":"<p>Pixel Wrangle has a system for managing presets. These presets are called 'presets'</p> <p>A Pixel-Wrangle preset contains both all the code you have written in each of the shader panels, as well as all the parameters and their state at the time of saving.</p> <p>To make it easier to load and filter presets, Pixel Wrangle provides a basic explorer with a file / folder hierarchy that reflects the structure of your file system</p> <p>The explorer allows you to find, load or save presets.</p> <p>It can be activated by clicking on the search area located at the bottom left of the interface or via the shortcut [CTRL] + Tab.</p> <p>You can then type in the name of your search to filter the results or scroll through the architecture.</p>"},{"location":"en/Presets/#important-paths","title":"Important paths","text":"<p>Presets are stored by default in the Presets folder at the root of Pixel Wrangle in your Palette.  </p> <p>There are 2 main folders:</p> <ul> <li>Builtins: This is the folder for presets shipped with Pixel Wrangle</li> <li>User: This is the folder where your presets are saved by default</li> </ul> <p>NB: If you want to build your own folder structure in your User folder, you can do so from your system's file explorer by clicking on the folder icon at the bottom left of the interface or using the shortcut [CTRL] + O.</p> <p>All the created subfolders are reflected in the Pixel Wrangle explorer.</p>"},{"location":"en/Presets/#load-a-preset","title":"Load a preset","text":"<p>To load a preset, simply double-click it from the Pixel Wrangle explorer.</p> <p>Warning, sometimes loading can be erratic, you may have to double-click several times. This is a known bug that should be fixed in upcoming versions of Pixel Wrangle</p>"},{"location":"en/Presets/#save-a-preset","title":"Save a preset","text":"<p>To save the state of your shader in a new preset, you can click on '+' in the UI. This will open a pop-up that will ask you under what name you want to save this preset. By default, this preset will be saved in the Presets/User folder from the root of Pixel Wrangle in your Palette.</p>"},{"location":"en/Quick%20Start/","title":"Quick Start","text":""},{"location":"en/Visual%20Studio%20Code/","title":"Visual Studio Code","text":""},{"location":"en/Visual%20Studio%20Code/#introduction","title":"Introduction","text":"<p>Pixel Wrangle offers the ability to edit your shader code within Visual Studio Code by default.</p> <p>Visual Studio Code is a very popular code editor offered by Microsoft, it is free and has a wide extension ecosystem.</p> <p>For more information, you can visit the official Visual Studio Code website.</p>"},{"location":"en/Visual%20Studio%20Code/#configuration","title":"Configuration","text":"<p>To take advantage of the Visual Studio Code integration within Pixel Wrangle, you must first set the path to the Visual Studio Code executable.</p> <p>By default it is located:</p> <ul> <li> <p>Either in your personal folder (if you are doing an installation for your user account only) =&gt; C:\\Users\\\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe <li> <p>Or in your system partition (if you are doing an installation for all users -&gt; requires administrator rights) =&gt; C:\\ProgramData\\Microsoft VS Code\\Code.exe To set the path to Visual Studio Code, you have two options:</p> </li> <li> <p>Through the Pixel Wrangle interface: (If the parameter is locked, you can right-click and then toggle read-only to enable 'Edit' mode) </p> </li> <li> <p>Through the settings.json file located in the root folder of the project: </p> </li> <p>Once this is done, you can launch your code editor in Visual Studio Code by pressing the corresponding button in the UI, or by pressing [CTRL] + E in the UI. This path will then be common to all your instances of Pixel Wrangle in all your projects.</p>"},{"location":"en/Visual%20Studio%20Code/#environment","title":"Environment","text":"<p>By default, the first time you launch Visual Studio Code through Pixel Wrangle, a new Visual Studio Code workspace is created. It will be used every time you open Visual Studio Code through a Pixel Wrangle instance.</p> <p>The goal is to not interfere with your existing Visual Studio Code environments and allow you to customize it to your liking (shortcuts, extensions, etc).</p> <p>Additionally, this environment will be preserved through updates of Pixel Wrangle as it is stored locally on your machine and remains independent of the Pixel Wrangle installation. By default, the location of this environment is: C:\\Users\\.vscode-td\\glsl"},{"location":"en/Visual%20Studio%20Code/#location-of-pixel-wrangles-temporary-files","title":"Location of Pixel Wrangle's Temporary Files","text":"<p>When writing code in Pixel Wrangle, each time a modification is made, the files are saved to the hard drive. The location of these files is in the general Touchdesigner temporary folder, which is typically located in:</p>"},{"location":"en/Visual%20Studio%20Code/#provided-code-profile","title":"Provided .code-profile","text":"<p>To start with, Pixel Wrangle offers a Visual Studio Code profile that includes a set of extensions, keyboard shortcuts. This configuration is intentionally minimalist and tailored for writing GLSL. In addition, some specific variables for the GLSL environment in Touchdesigner are injected, which allows for better autocompletion without having to perform imports.</p> <p>You can directly load this profile in Visual Studio Code using the command palette ([CTRL] + [SHIFT] + P), and run the command: 'Import Settings Profile'</p> <p></p> <p>If you want to load this profile file into your environment, you can find it at the root of the Pixel Wrangle project in your Palette</p> <p></p>"},{"location":"fr/","title":"Index","text":""},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/","title":"Coder avec Pixel-Wrangle","text":""},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#introduction","title":"Introduction","text":"<p>Pixel Wrangle propose un environnement de d\u00e9veloppement de pixel shaders impliquant un GLSL TOP sous-jacent. Il utilise donc le langage GLSL puisqu'il h\u00e9rite de GLSL TOP. GLSL TOP est une impl\u00e9mentation de GLSL propos\u00e9e par Touchdesigner dans son propre \u00e9cosyst\u00e8me, elle s'int\u00e8gre dans le workflow des TOP (Texture Operators dans la terminologie Touchdesigner). Pour plus d'informations sur le langage GLSL, rendez-vous sur la page GLSL Pour plus d'informations sur les TOP dans Touchdesigner, rendez-vous ici</p>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#vue-densemble-de-lediteur-de-pixel-wrangle","title":"Vue d'ensemble de l'\u00e9diteur de Pixel Wrangle","text":"<p>L'\u00e9dition du code dans Pixel-Wrangle se divise en 3 onglets dans l'fr/index:</p> <ul> <li>L'onglet 'IO' qui contient les panneaux 'Inputs' (vos variables 'uniform') et 'Outputs' (les buffers de sorties du shader). Ces panneaux font l'objet d'une syntaxe sp\u00e9cifique dont le d\u00e9tail complet se trouve ci-apr\u00e8s -&gt; Les particularit\u00e9s de l'onglet IO</li> <li>L'onglet 'Functions' qui accueille tout le code en dehors de la fonction main(). Vous pouvez y d\u00e9clarer vos fonctions personnalis\u00e9es, macros, variables partag\u00e9es, etc.</li> <li>L'onglet 'Main' qui correspond au corps de la fonction main(). Vous n'avez donc pas \u00e0 d\u00e9clarer cette fonction au sein de votre code mais juste \u00e9crire votre code comme vous le feriez dans la fonction main().</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#ordre-dexecution","title":"Ordre d'ex\u00e9cution","text":"<p>Le contenu en code des 3 onglets sont pars\u00e9s, puis envoy\u00e9s au compilateur dans l'ordre suivant :</p> <ol> <li>Macros</li> <li>IO -&gt; Inputs (uniform)</li> <li>Functions -&gt; imports avec #include + d\u00e9clarations de fonctions</li> <li>IO -&gt; Outputs (Buffers)</li> <li>Main (fonction main() avec votre code \u00e0 l'int\u00e9rieur)</li> </ol> <p>Pour visualiser le code complet (une fois pars\u00e9 : donc tel qu'il est envoy\u00e9 au compilateur), vous pouvez consulter le 'Full Code Panel' ([CTRL] + 9)</p>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#attention","title":"Attention","text":"<ul> <li>Les onglets 'Functions' et 'Main' utilisent tous deux la syntaxe GLSL standard donc vous pouvez \u00e9crire le code exactement comme vous l'\u00e9cririez dans n'importe quel shader GLSL.</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#mais","title":"MAIS","text":"<ul> <li>L'onglet 'IO' dispose d'une syntaxe particuli\u00e8re, expliqu\u00e9e en d\u00e9tail ci-apr\u00e8s</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#les-particularites-de-longlet-io","title":"Les particularit\u00e9s de l'onglet IO","text":""},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#panneau-des-inputs-variables-uniform","title":"Panneau des Inputs (variables uniform)","text":""},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#specificites-de-syntaxe","title":"Sp\u00e9cificit\u00e9s de syntaxe","text":"<ul> <li>Chacune des variables que vous d\u00e9clarez dans le panneau Inputs sont des variables uniforms mapp\u00e9es sur un param\u00e8tre de Touchdesigner.</li> <li>Pas de mot cl\u00e9 'uniform', il est implicite et est ajout\u00e9 automatiquement au moment du parsing par Pixel Wrangle, avant la compilation.</li> <li>Le nom de votre variable uniform refl\u00e8te le nom du param\u00e8tre Touchdesigner associ\u00e9.</li> <li>En cons\u00e9quence, le nom de votre variable doit imp\u00e9rativement commencer par une majuscule suivie de minuscules uniquement, et SANS caract\u00e8res sp\u00e9ciaux ou '_' (contrainte des noms de param\u00e8tres Touchdesigner)</li> <li>Le type de la variable d\u00e9termine le type du param\u00e8tre Touchdesigner qui y sera associ\u00e9 en suivant le m\u00eame sch\u00e9ma que les d\u00e9clarations de vos uniforms dans un GLSL TOP</li> <li>**Toute ligne de code d\u00e9butant par '//' ou '/*' est consid\u00e9r\u00e9e comme un commentaire, SAUF Cas sp\u00e9cifiques (Headers)</li> <li>**Toute d\u00e9claration de variable ou commentaire doit se faire sur une seule et unique ligne.</li> <li>**Pour personnaliser le param\u00e8tre Touchdesigner associ\u00e9 \u00e0 votre variable uniform, vous pouvez ajouter un commentaire \u00e0 la suite de la d\u00e9claration de votre variable suivi de paires propri\u00e9t\u00e9=valeur d\u00e9taill\u00e9es ici</li> <li>Les propri\u00e9t\u00e9s modifiables refl\u00e8tent ce que vous pourriez faire via le Component Editor, pas plus.</li> <li>**Chaque propri\u00e9t\u00e9 doit \u00eatre suivie d'un signe '=' puis de sa valeur.</li> <li>**Chaque couple [propri\u00e9t\u00e9=valeur] doit \u00eatre s\u00e9par\u00e9 par un ';'</li> <li>La liste des propri\u00e9t\u00e9s modifiables est consultable ci-dessous, dans la rubrique 'Propri\u00e9t\u00e9s modifiables'</li> <li>Les propri\u00e9t\u00e9s dont la valeur est une string ne doivent pas \u00eatre englob\u00e9es dans des ' ou des \", mais \u00e9crites directement, telles quelles.</li> <li>N\u00e9anmoins les propri\u00e9t\u00e9s dont la valeur est un array de string doivent \u00eatre \u00e9crites sous la forme [ 'Menu Entry 1' , 'Menu Entry 2' ]\\ avec des ' ou des \" englobant chaque \u00e9l\u00e9ment de l'array.</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#cas-specifiques-headers","title":"Cas sp\u00e9cifiques (Headers)","text":"<ul> <li>Les param\u00e8tres de type Header sont disponibles bien qu'ils n'aient pas de sens au niveau de GLSL, car ils sont utiles pour la mise en forme de l'UI.</li> <li>La syntaxe pour cr\u00e9er un param\u00e8tre de type Header est '//--- '.</li> <li>Vous pouvez ensuite lui associer une propri\u00e9t\u00e9 label et/ou section.</li> </ul> <p>Par exemple : '//--- label=Noise Types; section=1' cr\u00e9era un param\u00e8tre d'UI de type Header, avec pour titre : 'Noise Types', et disposera d'un s\u00e9parateur au dessus.</p> <ul> <li>Les autres param\u00e8tres non compatibles en tant que 'uniform' avec GLSL TOP comme les types 'File' ou 'Folder' ne sont pas disponibles via le panneau IO.</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#correspondance-des-types-glsl-style-de-parametres-td","title":"Correspondance des Types GLSL / Style de param\u00e8tres TD","text":"GLSL Type TD Parameter Style Syntax int Int OR Menu OR Toggle OR Pulse int Newint; float Float float Newfloat; vec[2-4] Float of size [2-4] OR Color for vec[3-4] vec3 Newcolor; uvec[2-4] Int of size [2-4] OR Color for vec[3-4] uvec2 Newunsignedvec; ivec[2-4] Int of size [2-4] OR Color for vec[3-4] ivec2 Newsignedvec; bvec[2-4] Int of size [2-4] OR Color for vec[3-4] bvec2 Newboolvec; \\&lt;TYPE&gt;[*] CHOP vec4 Newvectorarray[16] =&gt; !! Array of 16 vec4 values, needs to be referenced by a CHOP that holds the corresponding channels !! mat4 CHOP mat4 Newmatrix; atomic_uint Int atomic_uint Newatomicint; const int Int OR Menu OR Toggle OR Pulse const int Newconstantint = 0;"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#les-proprietes-modifiables","title":"Les propri\u00e9t\u00e9s modifiables","text":"Syntax Description Default Value label Parameter Label Parameter Name section Parameter has separator 0 order Parameter UI order (position) integer =&gt; Same as your declaration order readonly Parameter Lock 0 enable Parameter Activation 1 enableExpr Parameter Activation Expression '' help Parameter Help text on hover '' style Parameter Style Float or Color (for vec3-4) or Str or CHOP (according to variable type). Can be modified for int, float, vec3-4 (Valid values =&gt; Menu, Color, Toggle, Pulse, Float, Int) expr Parameter Expression '' bindExpr Parameter Bind Expression '' menu Parameter Menu entries (integer type only) '' default Parameter Default Value 0 or '' min Minimum Parameter Value 0 max Maximum Parameter Value 1 toggle Parameter is a toggle (integer type only) '' pulse Parameter is a Pulse (integer type only) '' chop Parameter chop path (mat4 type only) ''"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#exemples","title":"Exemples","text":"<pre><code>/* Syntax example */\n// Single line comments are ignored by the parser\n// Except for header (when line start with //---)\n//--- label=Simple Parameters; section=1\n// Create Float Parameter\nfloat Float; // default=0; min=-1; max=1; section=1\n// Create Integer Parameter\nint Int;     // min=-10; max=10; default=0\n//--- label=Vector Parameters; section=1\n// Create Color Vector Parameter\nvec3 Color;  // default=[0, 0.7, 1]; section=1\n// Create Vector style Parameter\nvec3 Position;  // default=[0, 0.7, 1]; style=Float\n//--- label=Menu Parameters; section=1\n// Create Menu Parameter\nint Newmenu;                  // menu=['Tomatoes', 'Bananas']; default=1; section=1\n//--- label=Array Parameters; section=1\n//// Create a uniform array of vec2 (you will need to specify a CHOP target with 2 channels and 16 samples each)\n// vec2 Array[16];  \n//// Create a texture buffer array of vec4 (you will need to specify a CHOP target with 4 channels and 200 samples each)\n// vec4 Array[200]; \n//// Create Matrix Parameter (you will need to specify a compatible 'chop' like transformCHOP to remove warning)\n// mat4 NewMatrix;\n/* Vulkan Specialization Constants */\nconst int ConstanttypeMenu = 0;     // menu=['Candies', 'Sky']; label=Vulkan Constant Menu\n//--- label=Atomic Counters; section=1\n// Create Atomic Counter\natomic_uint NewAtomicCounter; // section=1\n</code></pre>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#panneau-des-outputs-buffers","title":"Panneau des Outputs (Buffers)","text":""},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#generalites-au-sein-de-glsl-top","title":"G\u00e9n\u00e9ralit\u00e9s au sein de GLSL TOP","text":"<p>Les buffers sont des variables qui permettent de stocker et de partager des donn\u00e9es entre diff\u00e9rents shaders ou diff\u00e9rentes \u00e9tapes de rendu. Ils sont utiles pour l'accumulation de donn\u00e9es et la communication entre les diff\u00e9rents shaders d'un pipeline de rendu.</p> <p>Voici les 2 formes les plus utilis\u00e9es au sein du GLSL TOP de Touchdesigner :</p> <ul> <li> <p>Les buffers de textures (Accessible en mode Vertex/Pixel ET Compute): Ils permettent de r\u00e9f\u00e9rencer des textures qui seront utilis\u00e9es pour l'affichage. Ils sont g\u00e9n\u00e9ralement utilis\u00e9s dans les shaders pour LIRE des pixels de texture et les utiliser pour influencer la couleur finale du pixel.</p> </li> <li> <p>Les buffer d'images (Accessible en mode Compute UNIQUEMENT) : Ils permettent de LIRE ET \u00c9CRIRE dans des tampons de donn\u00e9es d'images tels que des textures ou des rendus offscreen. Ils sont g\u00e9n\u00e9ralement utilis\u00e9s dans les shaders pour effectuer des op\u00e9rations de traitement de l'image.</p> </li> </ul> <p>Il est \u00e9galement possible de d\u00e9clarer des buffers de textures d'images avec des dimensions sup\u00e9rieures \u00e0 2 (par exemple, une texture 3D ou une image 3D).</p> <p>Il est important de noter que les buffers de texture et d'image ne peuvent pas \u00eatre utilis\u00e9s de mani\u00e8re interchangeable. Chacun a sa propre syntaxe et ses propres fonctions d'acc\u00e8s.</p> <p>\u00c9galement, il est \u00e0 noter que les buffers d'image peuvent \u00eatre accessibles en \u00e9criture et en lecture mais seulement en mode 'Compute Shader', se r\u00e9f\u00e9rer \u00e0 la page GLSL des param\u00e8tres de Pixel Wrangle ou d'un GLSL TOP afin de r\u00e9gler cette option (Output Access).</p> <p>Concernant les buffers de texture : ils sont accessibles en lecture UNIQUEMENT mais disponible dans les 2 modes (Vertex/Pixel ET Compute)** avec la fonction texture().</p> <p>Par ailleurs, au sein d'un Pixel Shader en mode 'Compute', l'utilisation de texelFetch() est plus appropri\u00e9e pour lire les donn\u00e9es de texture car elle offre globalement de meilleures performances tout en permettant la gestion des niveaux de mipmap(ou LOD =&gt; Level Of Detail).</p>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#exemples-dans-un-glsl-top","title":"Exemples dans un GLSL TOP","text":"<p>En mode Vertex/Pixel :</p> <pre><code> // D\u00e9clarer un buffer en mode Pixel/Vertex \nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec4 otherColor;\nlayout(location = 2) out vec4 extraInfo;\nvoid main(){\n/* Assigner une valeur \u00e0 un buffer */\n// Ecrire la couleur rouge dans le buffer 'fragColor'\nfragColor = vec4(1,0,0,1); // Buffer 0 = Rouge\n// Ecrire la couleur de la premi\u00e8re entr\u00e9e 2D, \u00e9chantillonn\u00e9e avec les coordonn\u00e9es normalis\u00e9es vUV.st fournies par Touchdesigner.\notherColor = texture(sTD2DInputs[0], vUV.st); // Buffer 1 = Texture de la premi\u00e8re entr\u00e9e\n// Ecrire la couleur bleu dans le buffer 'fragColor'\nextraInfo = vec4(0,0,1,1); // Buffer 2 = Bleu\n}\n</code></pre> <p>En mode Compute:</p> <pre><code>/* \nLes Compute Shaders n'ont pas d'opinion sur le type de donn\u00e9es que vous leur fournissez, ni sur la mani\u00e8re de r\u00e9partir le calcul sur le GPU. \nCes aspects offrent une grande flexibilit\u00e9 mais n\u00e9cessitent de d\u00e9terminer en amont la fa\u00e7on dont vous souhaitez que les calculs s'effectuent sur votre carte graphique. \nPour plus d'informations \u00e0 ce sujet, vous pouvez vous r\u00e9f\u00e9rer \u00e0 la documentation officielle de GLSL.\nPour une explication br\u00e8ve du concept et son impl\u00e9mentation au sein de TD, rendez-vous sur https://docs.derivative.ca/Compute_Shader et https://docs.derivative.ca/Write_a_GLSL_TOP\n*/\n// D\u00e9clarer la taille des groupes de thread\nlayout (local_size_x = 8, local_size_y = 8) in;\n/*\nLa taille de groupe est utilis\u00e9e pour d\u00e9terminer comment les donn\u00e9es de texture sont partitionn\u00e9es et distribu\u00e9es aux threads de votre GPU. \nPar exemple, si vous utilisez une texture de 512 x 512 pixels et une taille de groupe de 8 x 8, vous aurez besoin de 64 groupes de threads pour couvrir la totalit\u00e9 de la texture.\nSi vous laissez le param\u00e8tre Auto-dispatch sur ON dans les param\u00e8tres de la page GLSL, GLSL TOP assignera automatiquement le nombre de groupe n\u00e9cessaires afin de couvrir l'int\u00e9gralit\u00e9 de la r\u00e9solution choisie, donc ici : 64. (512/8 pour chaque dimension).\nDans le cas contraire, vous devrez d\u00e9finir manuellement le nombre de groupe de threads via le param\u00e8tre Dispatch Size.\n*/\nvoid main(){\n// D\u00e9finir la couleur \nvec4 color = vec4(1,0,0,1); // Buffer 0 = Rouge\n// Ecrire la couleur rouge dans le buffer 0\nimageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), color);\n}\n</code></pre>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#gestion-des-buffers-avec-pixel-wrangle","title":"Gestion des buffers avec Pixel Wrangle","text":"<ul> <li>D\u00e9clarez vos buffers directement dans le panneau 'Outputs' de l'onglet 'IO', toujours de la m\u00eame mani\u00e8re, que vous soyez en mode Vertex/Pixel ou en mode Compute. De mani\u00e8re g\u00e9n\u00e9rale (bien qu'il n'y aie pas de r\u00e8gle absolue), je vous conseille d'utiliser des noms en CAPITALES afin de bien diff\u00e9rencier vos buffers de sortie de vos Inputs. Ci-dessous un exemple de d\u00e9claration de 3 buffers de sortie</li> </ul> <pre><code>vec4 IMAGE;\nvec4 POSITION;\nvec4 NORMALS;\n</code></pre> <ul> <li> <p>Pixel Wrangle cr\u00e9e imm\u00e9diatement les sorties n\u00e9cessaires avec leurs noms respectifs, vous les verrez appara\u00eetre sur l'instance de l'OP en tant que sorties de type TOP.</p> </li> <li> <p>Dans le m\u00eame temps, un onglet correspondant \u00e0 chacune de vos d\u00e9clarations sera visible dans les panneaux 'Viewer'</p> </li> <li> <p>Les sorties sont mapp\u00e9es dans l'ordre o\u00f9 elles ont \u00e9t\u00e9 d\u00e9clar\u00e9es. Si vous souhaitez modifier cet ordre, vous pouvez changer l'ordre de vos d\u00e9clarations.</p> </li> <li> <p>Par d\u00e9faut, chacune de ces d\u00e9clarations ajoute dynamiquement une macro correspondante pour y acc\u00e9der facilement dans les Compute Shaders. Pour reprendre l'exemple pr\u00e9c\u00e9dent, voici ce que cela donne dans le code envoy\u00e9 au compilateur :</p> </li> </ul> <pre><code>#define IMAGE mTDComputeOutputs[0]\n#define POSITION mTDComputeOutputs[1]\n#define NORMALS mTDComputeOutputs[2]\n</code></pre> <ul> <li>Ensuite, vous pouvez donc \u00e9crire dans ces buffers de la mani\u00e8re suivante depuis l'onglet 'Main' :</li> </ul>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#en-mode-vertexpixel","title":"En mode Vertex/Pixel","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shorthand for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1); /* Write vec4 'c' in 'IMAGE' Buffer, td() is a shorthand for TDOutputSwizzle() */\nIMAGE = td(c)\n/* \nPour en savoir plus sur les macros utilis\u00e9es ci-dessus, vous pouvez vous rendre sur la page [Macros](./Macros.md), vous y trouverez une liste compl\u00e8te des macros utilisables dans Pixel Wrangle.\nElles sont \u00e9galement consultables depuis le panneau 'Macros' en haut \u00e0 gauche dans l'interface, ou directement depuis le panneau 'Full Code' telles qu'elles sont envoy\u00e9es au compilateur.\n*/\n</code></pre>"},{"location":"fr/Coder%20avec%20Pixel%20Wrangle/#en-mode-compute","title":"En mode Compute","text":"<pre><code>/* Read Position-Normalized-Centered-Ratio from macro and store it in a vec4 called 'c' */\n// _PNCR is a Shortcut for Position-Normalized-Centered-RatioAlongMaxAxis\nvec4 c = vec4(_PNCR,1); /* Write vec4 'c' in 'IMAGE' Buffer using Absolute Coordinates */\n// Shortcut for imageStore(mTDComputeOutputs[0], ivec2(gl_GlobalInvocationID.xy), TDOutputSwizzle(c))\nstore(IMAGE, _UV, td(c));\n</code></pre>"},{"location":"fr/Contribuer/","title":"Contribuer au projet","text":"<p>Je pr\u00e9cise avant tout que je n'invite pour le moment personne \u00e0 se servir de Pixel Wrangle au sein de productions qui n\u00e9cessitent avant tout de la stabilit\u00e9.</p> <p>Ce projet n'en est qu'\u00e0 ses d\u00e9buts, il est donc tr\u00e8s probable que vous rencontriez des bugs et que des breaking changes aient lieu sur les premi\u00e8res it\u00e9rations.</p> <p>Toute RFE est \u00e9videmment la bienvenue via la section d\u00e9di\u00e9 sur le repo GitHub. N\u00e9anmoins je ne peux pour l'heure garantir une r\u00e9activit\u00e9 sans faille quant aux corrections de bugs et \u00e0 l'impl\u00e9mentation de nouvelles features (mais je ferai de mon mieux).</p> <p>D'autre part, si quelqu'un est int\u00e9ress\u00e9 pour m'aider \u00e0 faire vivre ce projet, je serai ravi de pouvoir \u00e9changer et collaborer \u00e0 ce sujet. Malgr\u00e9 le fait que les .tox de TD soient des binaires, il est tout de m\u00eame possible de charger des scripts depuis l'ext\u00e9rieur, donc finalement pas mal de choses sont externalisables (dont les scripts Python les plus bancals \u00e0 ce jour).</p> <p>A disposition pour \u00e9changer, prioritairement via GitHub, sinon par mail \u00e0 l'adresse suivante : studio.miu.lab@gmail.com</p>"},{"location":"fr/D%C3%A9marrer%20rapidement%20avec%20Pixel%20Wrangle/","title":"D\u00e9marrer rapidement","text":""},{"location":"fr/Fonctions/","title":"Fonctions","text":""},{"location":"fr/Fonctions/#bibliotheques-externes","title":"Biblioth\u00e8ques externes","text":""},{"location":"fr/Fonctions/#introduction","title":"Introduction","text":"<p>Pixel Wrangle est con\u00e7u comme un environnement modulaire. Il est donc possible d'\u00e9tendre les fonctions disponibles via des biblioth\u00e8ques GLSL existantes, ou en construisant vos propres biblioth\u00e8ques en sauvant des fonctionnalit\u00e9s que vous pouvez ensuite rappeler dans tout vos projets.  Cela peut-\u00eatre utile lorsque vous souhaitez r\u00e9utiliser du code de mani\u00e8re plus granulaire que vous ne pourriez le faire avec des presets.  Notez aussi que lorsque vous importez des biblioth\u00e8ques externes, elles deviennent disponible au travers de tout votre projet, cela veut donc dire que vous pouvez tout \u00e0 fait r\u00e9f\u00e9rencer ces imports dans un GLSL TOP nu, ind\u00e9pendamment de l'utilisation de Pixel Wrangle  </p>"},{"location":"fr/Fonctions/#lygia","title":"Lygia","text":"<p>Par d\u00e9faut, Pixel Wrangle fournit une biblioth\u00e8que de fonctions granulaires tr\u00e8s compl\u00e8te appel\u00e9e Lygia. Lygia est un projet communautaire port\u00e9 notamment par Patricio Gonzalez Vivo, qui est aussi \u00e0 l'origine de https://thebookofshaders.com, un guide d'introduction aux fragment shaders. Pour plus d'informations sur cette biblioth\u00e8que et son contenu, vous pouvez aussi consulter le GitHub officiel</p>"},{"location":"fr/Fonctions/#fichiers-et-dossiers-importants","title":"Fichiers et dossiers importants","text":"<p>Les fichiers relatifs aux biblioth\u00e8ques externes sont stock\u00e9s dans le dossier Functions \u00e0 la racine du projet Pixel Wrangle. Pour ajouter une biblioth\u00e8que externe de votre choix, vous pouvez cloner son contenu dans le dossier Functions/src/&lt;Nom de la biblioth\u00e8que&gt;</p> <p></p> <p>Dans les sections suivantes, vous verrez comment int\u00e9grer ces biblioth\u00e8ques dans vos projets. Je pr\u00e9cise \u00e9galement que pour que la biblioth\u00e8que soit lisible par Pixel Wrangle, les fichiers doivent avoir une extension en '.glsl', tout autre type de fichier sera ignor\u00e9.</p>"},{"location":"fr/Fonctions/#auto-parsing","title":"Auto-parsing","text":"<p>Pixel Wrangle fournit un outil de parsing sommaire qui permet de rendre compatible des libraries \u00e9crites en GLSL pur, en GLSL compatible avec l'\u00e9cosyst\u00e8me Touchdesigner.</p> <p>Cela concerne en premier lieu la forme des chemins d'imports qui sont sp\u00e9cifiques \u00e0 Touchdesigner, mais aussi la conversion de certains noms de fonction comme texture2D(), et autres afin que la librairie s'ex\u00e9cute correctement dans l'environnement Touchdesigner.</p> <p>Le principe est le suivant :</p> <ul> <li>Vous d\u00e9posez vos dossiers de biblioth\u00e8ques brutes dans le dossier Functions/src comme d\u00e9crit pr\u00e9c\u00e9demment</li> <li>Vous parsez vos biblioth\u00e8ques directement depuis l'interface de Pixel Wrangle (Pressez juste 'Build Libraries' depuis la page 'Code/Plugin')</li> <li>Une fois les biblioth\u00e8ques pars\u00e9es, une copie compatible avec Touchdesigner de l'architecture des fichiers / dossiers est effectu\u00e9e automatiquement dans le dossier 'Functions/dist'</li> </ul>"},{"location":"fr/Fonctions/#import-des-bibliotheques-dans-le-projet","title":"Import des biblioth\u00e8ques dans le projet","text":"<p>Pour importer les biblioth\u00e8ques dans votre projet, il vous suffit de presser 'Import Libraries' depuis la page 'Code/Plugin'. Cela cr\u00e9era toute l'architecture de fichiers/dossiers \u00e0 la racine de votre projet Touchdesigner, dans un BaseCOMP appel\u00e9 'libs'. Chaque import en ''.glsl' est en fait un TextDAT en mode Sync File, qui pointe vers le fichier correspondant du dossier Functions/dist (la copie du fichier apr\u00e8s parsing)</p> <p>Du fait que l'architecture des librairies soit int\u00e9gr\u00e9e \u00e0 la racine de votre projet, vous pouvez tout \u00e0 fait r\u00e9utiliser toutes les fonctions dans un contexte de GLSL TOP sans passer par l'enveloppe de Pixel Wrangle. </p>"},{"location":"fr/Fonctions/#inclure-des-fonctions-dans-votre-instance-pixel-wrangle","title":"Inclure des fonctions dans votre instance Pixel Wrangle","text":"<p>En pressant le raccourci [CTRL] + [SHIFT] + [TAB], ou en cliquant dans la barre de recherche en bas \u00e0 droite de l'interface, vous acc\u00e9dez \u00e0 l'explorateur de fonctions.  Cet explorateur renvoie la liste de toutes les fonctions disponibles au sein de votre projet. Vous pouvez ensuite effectuer une recherche en tapant un mot-cl\u00e9, la liste est filtr\u00e9e automatiquement. </p> <p>Pixel Wrangle vous proposera \u00e9galement la documentation d'en-t\u00eate de toutes vos fonctions, ainsi que toutes les signatures que vous pouvez copier coller directement dans votre code.</p> <p>Enfin, vous pouvez double-cliquer sur la fonction dans la liste, cela l'importera dans votre instance Pixel Wrangle. Vous pouvez voir l'inclusion appara\u00eetre dans votre panneau 'Fonctions'</p>"},{"location":"fr/Fonctions/#ajouter-vos-propres-fonctions","title":"Ajouter vos propres fonctions","text":"<p>Si vous souhaitez ajouter de nouvelles fonctions au fur et \u00e0 mesure de votre utilisation de Pixel Wrangle, vous pouvez le faire via la fonction '+' dans le panneau des Fonctions. Il vous sera alors demand\u00e9 le nom du fichier \u00e0 sauvegarder ainsi qu'un commentaire en t\u00eate de fichier afin de donner des informations utiles sur le r\u00f4le de ce fichier et de ses fonctions. Par d\u00e9faut, ces presets sont sauv\u00e9s \u00e0 la racine de votre dossier Functions/user dans un fichier au format '.glsl'. Vous pouvez ensuite les placer dans les dossiers de votre choix et d\u00e9finir la hi\u00e9rarchie de votre choix dans votre </p>"},{"location":"fr/Fonctions/#organiser-vos-fonctions-en-une-librairie-utile","title":"Organiser vos fonctions en une librairie utile","text":"<p>Il n'y a pas de m\u00e9thode particuli\u00e8re pour cr\u00e9er vos propres biblioth\u00e8ques de fonctions GLSL, cependant quelques recommandations :  - Il est pr\u00e9f\u00e9rable d'\u00e9viter de cr\u00e9er des d\u00e9pendances \u00e0 des fonctions d'autres biblioth\u00e8ques afin de pr\u00e9server la portabilit\u00e9 de votre biblioth\u00e8que dans diff\u00e9rents contextes - Tant que possible, essayer d'organiser vos fichiers de fonctions de mani\u00e8re granulaire et d'adopter une hi\u00e9rarchie par utilit\u00e9 / contexte pour plus de clart\u00e9  - Hormis pour faire de la surcharge de fonctions, d\u00e9clarer des variantes de signatures d'une m\u00eame fonction, il est conseill\u00e9 de n'avoir qu'une seule fonctionnalit\u00e9 par fichier - </p>"},{"location":"fr/GLSL/","title":"Le langage GLSL","text":""},{"location":"fr/GLSL/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>GLSL est un langage compil\u00e9 de type C, con\u00e7u pour cr\u00e9er des shaders. Il a \u00e9t\u00e9 cr\u00e9\u00e9 et est maintenu par le consortium \u00e0 but non-lucratif Khronos Group qui est \u00e0 l'origine du standard open-source OpenGL (et maintenant Vulkan qui \u00e0 terme prendra sa place).</p> <p>Un shader est un petit programme informatique r\u00e9duit \u00e0 un champ d'action sp\u00e9cifique. Il est g\u00e9n\u00e9ralement destin\u00e9 \u00e0 afficher des choses \u00e0 l'\u00e9cran. Les shaders en GLSL sont ex\u00e9cut\u00e9s sur votre processeur graphique (GPU).</p> <p>GLSL est en mesure d'intervenir \u00e0 plusieurs niveau du processus de rendu d'une image.</p> <p>Toutes les \u00e9tapes n\u00e9cessaires pour fournir le r\u00e9sultat final est appel\u00e9 le pipeline de rendu.</p> <p>GLSL s'int\u00e8gre donc au sein d'applications graphiques utilisant les API OpenGL, Vulkan, WebGL, et plus encore...</p> <p>Depuis les builds 2022, Touchdesigner int\u00e8gre GLSL au travers de Vulkan, la derni\u00e8re API graphique de Khronos qui finira par remplacer OpenGL \u00e0 terme.</p> <p>Le logiciel propose une impl\u00e9mentation de GLSL via 2 de ses op\u00e9rateurs natifs : GLSL TOP (Texture) et GLSL MAT (Materials)</p> <p>Il est important de noter que les shaders en GLSL s'ex\u00e9cutent de mani\u00e8re parall\u00e8le sur votre machine. Ils permettent donc de tirer parti de la puissance des processeurs graphiques (GPU) et offrent de tr\u00e8s bonnes performances pour des applications n\u00e9cessitant du temps r\u00e9el.</p> <p>Quelques fondamentaux en programmation sont toutefois n\u00e9cessaires pour exploiter pleinement le potentiel des shaders ou les adapter \u00e0 ses propres besoins. De plus, la programmation d'un GPU (parall\u00e9lisme des calculs) implique une structure du code particuli\u00e8re et certaines contraintes qui peuvent mettre un peu de temps \u00e0 \u00eatre appr\u00e9hend\u00e9es.</p> <p>Je ne peux que vous conseiller la lecture de l'excellent https://thebookofshaders.com qui permet de mieux comprendre ces concepts, d'autant qu'une grande partie du contenu y est traduit dans de nombreuses langues.</p> <p>Enfin, GLSL d\u00e9coulant directement du langage C, la syntaxe et la s\u00e9mantique en sont tr\u00e8s proche.</p> <p>Cependant, quelques diff\u00e9rences notables par rapport au C sont pr\u00e9sentes, notamment :</p> <ul> <li>Une syntaxe raccourcie pour manipuler des vecteurs (appel\u00e9e vector swizzling)</li> <li>Une biblioth\u00e8que native comportant des fonctions math\u00e9matiques usuelles ainsi que d'autres fonctions sp\u00e9cifiques aux shaders</li> <li>Des types sp\u00e9ciaux (matrices, samplers, etc.) d\u00e9di\u00e9s \u00e0 la manipulation des shaders.</li> <li>Ainsi que plein d'autres choses que je vous invite \u00e0 d\u00e9couvrir par vous m\u00eame, via la documentation officielle.</li> </ul> <p>Vous d\u00e9couvrirez \u00e9galement que certaines fonctionnalit\u00e9s de C sont absentes.</p> <p>Par exemple certains types comme les cha\u00eenes de caract\u00e8res n'ont pas d'existence au sein de GLSL. Ceci est en partie d\u00fb aux contraintes qu'impose l'architecture des GPU actuels, ainsi que sur leur mani\u00e8re d'effectuer des calculs.</p> <p>Pour finir, vous trouverez ci-dessous une liste de liens utiles dans votre parcours.</p>"},{"location":"fr/GLSL/#liens-utiles","title":"Liens utiles","text":"<p>[!INFO]</p> <ul> <li> <p>Une ressource indispensable pour bien commencer si vous n'avez jamais manipul\u00e9 de shaders (The Book of Shaders).</p> </li> <li> <p>Une vue g\u00e9n\u00e9rale des sp\u00e9cifications du langage en vid\u00e9o.</p> </li> <li> <p>La documentation officielle du langage accessible sur le site de Khronos via un PDF \u00e0 t\u00e9l\u00e9charger.</p> </li> <li> <p>Un index des fonctions inclues dans la biblioth\u00e8que standard de GLSL.</p> </li> <li> <p>Plus de d\u00e9tails sur l'impl\u00e9mentation de GLSL TOP (l'op\u00e9rateur sous-jacent de Pixel Wrangle) dans Touchdesigner.</p> </li> <li> <p>Shadertoy, un site web qui permet la cr\u00e9ation de shaders en ligne via WebGL. C'est un endroit fantastique o\u00f9 vous trouverez de nombreux exemples de shaders cr\u00e9\u00e9s par la communaut\u00e9.</p> </li> <li> <p>Le site web de Inigo Quiles est \u00e9galement une source d'apprentissage massive pour comprendre diff\u00e9rents m\u00e9canisme li\u00e9s \u00e0 la cr\u00e9ation de shaders et aux maths sous-jacentes.</p> </li> <li> <p>Lygia est un projet communautaire port\u00e9 entre autres par Patricio Gonzalez Vivo (The Book of Shaders), il s'agit d'une biblioth\u00e8que de fonctions GLSL (et HLSL) qui d\u00e9livre une quantit\u00e9 importante de fonctions tr\u00e8s utiles. Elle est nativement fournie avec Pixel Wrangle et facilite grandement le travail.</p> </li> <li> <p>De nombreuses vid\u00e9os YouTube traitent de la cr\u00e9ation de shaders. Certaines dans le contexte de Touchdesigner, Unity, Shadron, glslsandbox, ou d'autres frameworks. La cha\u00eene YouTube The Art Of Code propose par exemple une bonne introduction par la pratique \u00e0 GLSL sur Shadertoy.</p> </li> </ul>"},{"location":"fr/GLSL/#pipeline-de-rendu","title":"Pipeline de rendu","text":"<p>GLSL est un langage pouvant \u00eatre utilis\u00e9s \u00e0 diff\u00e9rentes \u00e9tapes du pipeline de rendu.</p> <p>Chaque \u00e9tape du pipeline dispose de certaines variables et fonctions qui lui sont propre</p> <p>Voici une liste (non exhaustive et probablement inexacte sur certains points) des \u00e9tapes du pipeline, dans un ordre chronologique :</p> <ul> <li> <p>Vertex Specification : Il s'agit de l'\u00e9tape initiale, elle consiste \u00e0 r\u00e9cup\u00e9rer la liste des points et primitives ainsi que leurs attributs (id, position, etc...) dans la m\u00e9moire du CPU puis les convertir dans un format exploitable pour la suite des \u00e9tapes du pipeline de rendu dans la m\u00e9moire du GPU. Cette \u00e9tape est r\u00e9alis\u00e9e de mani\u00e8re automatique par Touchdesigner et le backend OpenGL/Vulkan lors de l'utilisation d'un GLSL TOP sur un Geometry COMP</p> </li> <li> <p>Vertex Shader : C'est un programme qui s'applique au niveau de la g\u00e9om\u00e9trie d'un objet 3D, il est ex\u00e9cut\u00e9 simultan\u00e9ment sur chaque vertex de la g\u00e9om\u00e9trie d'entr\u00e9e. Il permet notamment de cr\u00e9er et modifier des attributs comme la position des points pour d\u00e9former un objet par exemple. Le r\u00e9sultat des ces op\u00e9rations est ensuite pass\u00e9 \u00e0 l'\u00e9tape suivante du pipeline de rendu. Certaines \u00e9tapes interm\u00e9diaires peuvent \u00eatre effectu\u00e9es \u00e0 ce stade (se r\u00e9f\u00e9rer aux Geometry Shaders, Tessellation Shaders...)</p> </li> <li> <p>Rasterization : La rasterization est une op\u00e9ration qui permet de transformer une sc\u00e8ne d\u00e9crite dans un espace en 3 dimensions, en une image en 2 dimensions affichable par un \u00e9cran \u00e0 une r\u00e9solution choisie (discr\u00e9tisation). Vous pouvez imaginer cette \u00e9tape comme la projection de notre espace \u00e9cran (la vue), sur le ou les objets 3D de la sc\u00e8ne. Cette op\u00e9ration est r\u00e9alis\u00e9e par le backend OpenGL / Vulkan de mani\u00e8re transparente et automatique. Il n'y a pas de shader associ\u00e9 permettant d'avoir un contr\u00f4le sur cette \u00e9tape du pipeline mais elle est cruciale dans le pipeline de rendu</p> </li> <li> <p>Pixel Shader (ou Fragment Shader) : C'est un programme qui s'ex\u00e9cute sur chaque pixel rendu \u00e0 l'\u00e9cran. Un pixel shader permet de manipuler ces diff\u00e9rentes donn\u00e9es afin de produire la couleur finale des pixels.</p> </li> </ul> <p>-&gt; Dans le cas d'un objet 3D issu d'un vertex shader, le Pixel shader effectue une interpolation des valeurs des attributs fournis par le vertex shader. Vous pouvez ensuite les manipuler \u00e0 votre guise pour obtenir le r\u00e9sultat souhait\u00e9</p> <p>-&gt; Dans le cas o\u00f9 il n'est pas fourni de Vertex Shader. L'impl\u00e9mentation du Pixel shader de Touchdesigner (GLSL TOP) fourni de base 2 triangles rectangle qui forment un rectangle aux dimensions exactes de l'\u00e9cran. Vous disposez donc d'un syst\u00e8me de coordonn\u00e9es \u00e0 partir du quel vous pouvez vous amuser. A noter qu'il est tout \u00e0 fait possible de cr\u00e9er des images 3D sans passer par le vertex shader ni une g\u00e9om\u00e9trie compos\u00e9e de points. Cela implique que toute la logique soit cod\u00e9e dans le pixel shader. Le Raymarching (ou 'Sphere Tracing') est une de ces techniques. Elle est bas\u00e9e sur la description des formes par des champs de distance appel\u00e9s SDF. Vous pourrez trouver \u00e9norm\u00e9ment d'exemples sur Shadertoy et le le site d'Inigo Quiles si vous souhaitez en savoir plus sur ces techniques. Concernant le ray-marching dans Touchdesigner le projet rayTK port\u00e9 par tekt est un exemple merveilleux du portage de cette technique dans l'environnement de Touchdesigner. Il simplifie grandement son utilisation au travers d'un \u00e9cosyst\u00e8me d'op\u00e9rateurs pr\u00e9construits. Un conseil, allez voir ca !</p> <p>Dans Touchdesigner, GLSL peut \u00eatre utilis\u00e9 via GLSL TOP (G\u00e9n\u00e9ration d'images dans le contexte TOP) ou GLSL MAT (G\u00e9n\u00e9ration de mat\u00e9riaux pour des objets 3D).</p> <p>NB : L'environnement de travail propos\u00e9 par Pixel Wrangle ne fonctionne actuellement qu'avec GLSL TOP</p>"},{"location":"fr/GLSL/#pixel-shader","title":"Pixel Shader","text":"<p>Dans le cas d'un pixel shader sans vertex shader associ\u00e9 manuellement (le comportement par d\u00e9faut de Pixel Wrangle),  la chose que vous manipulez effectivement au sein de la fonction main() de votre shader est le pixel courant.</p> <p>Ce pixel poss\u00e8de une caract\u00e9ristique intrins\u00e8que et fondamentale, sa position dans l'espace \u00e9cran. Dans le cas d'une image en 2 dimensions par exemple, il s'agit des coordonn\u00e9es en x et en y.</p> <p>Il est important de comprendre que ce m\u00eame programme est ex\u00e9cut\u00e9 simultan\u00e9ment sur chacun des pixels composant votre image finale.</p> <p>Pour une image de 1024 * 1024 pixels par exemple, ce programme sera ex\u00e9cut\u00e9 1024 * 1024 fois, soit un total de 1 048 576 fois. C'est beaucoup.</p> <p>Dans le cas d'un processeur standard (CPU), toutes ces ex\u00e9cutions seraient effectu\u00e9es de mani\u00e8re s\u00e9quentielle (ou au mieux, r\u00e9parties sur les quelques c\u0153urs que compte votre CPU).</p> <p>Un CPU est tr\u00e8s efficace pour la plupart des t\u00e2ches quotidiennes avec un ordinateur et dispose d'un stockage m\u00e9moire rapide et cons\u00e9quent (RAM), en revanche il se r\u00e9v\u00e8le peu efficace lorsque vous avez besoin d'effectuer un m\u00eame traitement sur un grand nombre d'\u00e9l\u00e9ment \u00e0 la fois comme c'est le cas pour une image compos\u00e9e de pixels.</p> <p>Au contraire, un shader s'ex\u00e9cute sur votre processeur graphique (GPU). Les GPU ont une architecture diff\u00e9rente des CPU, qui est con\u00e7ue pour ex\u00e9cuter un grand nombre de t\u00e2ches \u00e0 la fois. A titre de comparaison, un GPU compte de quelques milliers de c\u0153urs \u00e0 plus de 10000 pour des GPU haut de gamme. Cela permet de r\u00e9duire grandement le nombre d'op\u00e9rations effectu\u00e9es en un m\u00eame instant puisque les calculs sont r\u00e9partis dans chacun des milliers de c\u0153urs que compte votre GPU.</p> <p>Les principales limitations du GPU :</p> <ul> <li>Un espace m\u00e9moire limit\u00e9 (la VRAM est ch\u00e8re et de taille fixe), cela induit une certaine limite de taille et de complexit\u00e9 des op\u00e9rations, plus facilement atteignable qu'avec un CPU.</li> <li>Une vitesse d'ex\u00e9cution s\u00e9quentielle (par c\u0153ur de GPU) moins \u00e9lev\u00e9 que votre CPU</li> <li>Les GPU actuels effectuent des calculs avec des nombres exclusivement, les rendant difficilement utilisables pour des t\u00e2ches manipulant des cha\u00eenes de caract\u00e8re ou certains types de donn\u00e9es complexes qui sont courant dans la programmation traditionnelle.</li> <li>Les possibilit\u00e9s d'abstraction sont r\u00e9duites, le p\u00e9rim\u00e8tre des op\u00e9rations est limit\u00e9</li> </ul>"},{"location":"fr/GLSL/#gpu-vs-cpu-par-lexemple","title":"GPU vs CPU par l'exemple","text":"<p>CPU :</p> <ul> <li>Ecrire 2 boucles 'for' imbriqu\u00e9es, it\u00e9rant chacune sur les coordonn\u00e9es x et y de l'image.</li> <li>Ex\u00e9cuter votre fonction main() avec tout votre code au sein de vos 2 boucles, sur chacun des pixels composant votre image.</li> </ul> <pre><code>int ResolutionX = 1024;\nint ResolutionY = 1024;\nfor(int x=0; x&lt;ResolutionX; x++){\nfor(int y=0; y&lt;ResolutionY; y++){\n/* Intrinsic Attributes */\nuvec2 absolutePositionOfCurrentPixel   = uvec2(x,y);                                                           // -&gt; Absolute Coordinates   (with x and y integer values between 0 and Resolution-1)\nvec2 normalizedPositionOfCurrentPixel =  vec2(float(x)/float(ResolutionX-1),float(y)/float(ResolutionY-1));   // -&gt; Normalized Coordinates (with x and y float values between 0 and 1) =&gt; vUV.st\n/* Your main() function in a 2D Pixel Shader is executed here */\n// Your awesome stuff...\n// ...\n}\n}\n</code></pre> <p>Pixel Shader (GPU) :</p> <ul> <li>Les coordonn\u00e9es vous sont d\u00e9j\u00e0 fournis par le contexte principal par une variable. Nomm\u00e9e vUV dans Touchdesigner</li> <li>Ecrivez juste votre code dans la fonction main() en r\u00e9cup\u00e9rant directement les coordonn\u00e9es fournies par le shader (vUV) Cela aurait la forme suivante pour une image de 1024 * 1024 pixels : Au sein de la fonction main() d'un pixel shader, vous pouvez consid\u00e9rer que chacune de vos instructions sont ex\u00e9cut\u00e9es simultan\u00e9ment, et que le contexte d'ex\u00e9cution est la partie interne de cette double boucle 'for'.</li> </ul> <p>GLSL et Vulkan se chargent de r\u00e9partir intelligemment l'ex\u00e9cution du programme simultan\u00e9ment sur tous les c\u0153urs disponibles de votre GPU.</p>"},{"location":"fr/GLSL/#coordonnees-du-pixel","title":"Coordonn\u00e9es du pixel","text":"<p>Dans Touchdesigner, les coordonn\u00e9es x et y normalis\u00e9es vous sont fournies sous la forme d'un vecteur dans votre shader via une variable fournie directement par le contexte d'ex\u00e9cution.</p> <p>Il s'agit de la variable vUV</p> <pre><code>vec2 coords = vUV.xy; // Will store a copy of current XY coord in 'coords' vec2 variable\n</code></pre>"},{"location":"fr/Installation/","title":"Installation","text":""},{"location":"fr/Installation/#prerequis","title":"Pr\u00e9requis","text":"<p>La seule chose dont vous avez n\u00e9cessairement besoin pour commencer est une version de Touchdesigner r\u00e9cente (builds 2022.XX et ult\u00e9rieures) install\u00e9e sur votre machine.</p> <p>Si vous n'avez pas de licence, vous pouvez tout de m\u00eame utiliser Touchdesigner avec une licence 'NON-COMMERCIAL'. Ces versions poss\u00e8dent la grande majorit\u00e9 des fonctionnalit\u00e9s et permettent en l'\u00e9tat de faire fonctionner Pixel-Wrangle.</p> <p>Touchdesigner est accessible en t\u00e9l\u00e9chargement en suivant ce lien,  il vous donnera un aper\u00e7u des diff\u00e9rents mod\u00e8les de licences.</p> <p>Accessoirement, vous pouvez t\u00e9l\u00e9charger Git si vous souhaitez mettre \u00e0 jour les futures versions de Pixel Wrangle directement via votre Terminal</p> <p>Enfin, si vous souhaitez profiter de la documentation (en Markdown) dans les meilleures conditions, vous pouvez t\u00e9l\u00e9charger Obsidian. Vous y aurez acc\u00e8s ind\u00e9pendamment de votre connexion internet avec une interface sympa.</p>"},{"location":"fr/Installation/#telecharger-le-projet","title":"T\u00e9l\u00e9charger le projet","text":"<p>Une fois Touchdesigner install\u00e9,</p>"},{"location":"fr/Installation/#si-vous-navez-pas-installe-git","title":"Si vous n'avez pas install\u00e9 Git","text":"<ul> <li>T\u00e9l\u00e9charger le d\u00e9p\u00f4t au format ZIP depuis https://github.com/miu-lab/TD-Pixel-Wrangle en cliquant sur 'Download ZIP' </li> </ul>"},{"location":"fr/Installation/#installer-pixel-wrangle","title":"Installer Pixel Wrangle","text":""},{"location":"fr/Installation/#si-vous-navez-pas-installe-git_1","title":"Si vous n'avez pas install\u00e9 Git :","text":"<ul> <li> <p>D\u00e9placez le zip t\u00e9l\u00e9charg\u00e9 dans C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\Documents\\Derivative\\Palette et extrayez son contenu dans ce dossier comme indiqu\u00e9 ci-dessous</p> </li> <li> <p>Attention, il est important que le dossier racine du projet aie pour nom exact : TD-Pixel-Wrangle</p> </li> </ul> <p></p>"},{"location":"fr/Installation/#ou-si-vous-avez-installe-git","title":"OU Si vous avez install\u00e9 Git","text":"<p>Lancez un terminal dans le dossier C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\Documents\\Derivative\\Palette ou naviguez-y avec cd puis faites un 'git clone' du projet</p> <pre><code>git clone https://github.com/miu-lab/TD-Pixel-Wrangle.git\n</code></pre>"},{"location":"fr/Installation/#configuration","title":"Configuration","text":"<p>Si vous souhaitez travailler avec Visual Studio Code, vous pouvez tout de suite pr\u00e9ciser le chemin de l'ex\u00e9cutable dans le fichier 'settings.json' \u00e0 la racine du projet.</p> <pre><code>{\"vscodePath\": \"C:\\\\Users\\\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\\\AppData\\\\Local\\\\Programs\\\\Microsoft VS Code\\\\Code.exe\"}\n</code></pre> <p>Pour plus de d\u00e9tails sur l'utilisation conjointe de Pixel Wrangle avec Visual Studio Code, rendez-vous sur la page VSCode</p>"},{"location":"fr/Installation/#documentation","title":"Documentation","text":"<p>Si vous souhaitez acc\u00e9der \u00e0 la documentation en local et dans les meilleures conditions comme \u00e9voqu\u00e9 plus t\u00f4t, vous pouvez t\u00e9l\u00e9charger Obsidian.</p> <p>Vous pourrez ensuite ouvrir un coffre (coffre : terminologie Obsidian pour d\u00e9signer une architecture de fichier et dossiers en markdown).</p> <p>Le coffre de la documentation est stock\u00e9 dans le dossier 'doc' \u00e0 la racine du projet, vous pouvez l'ouvrir directement dans Obsidian Chemin : C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\Documents\\Derivative\\Palette\\TD-Pixel-Wrangle\\doc</p>"},{"location":"fr/Installation/#mise-a-jour-de-la-palette-touchdesigner","title":"Mise \u00e0 jour de la Palette Touchdesigner","text":"<p>Lorsque vous lancez Touchdesigner \u00e0 la suite de ces \u00e9tapes, il peut \u00eatre n\u00e9cessaire de faire un refresh de la Palette Touchdesigner. </p>"},{"location":"fr/Macros/","title":"Les Macros","text":""},{"location":"fr/Macros/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>En GLSL, les macros sont des instructions qui permettent de d\u00e9finir du code r\u00e9utilisable. Elles sont similaires aux macros de C et sont d\u00e9finies \u00e0 l'aide de la directive <code>#define</code>. Les macros peuvent \u00eatre utiles pour simplifier le code et le rendre plus lisible, mais il faut \u00eatre vigilant \u00e0 ne pas en abuser car elles peuvent rendre le code difficile \u00e0 comprendre et \u00e0 d\u00e9boguer. Par d\u00e9finition, l'\u00e9valuation d'une macro a lieu au moment de la compilation (static), et non du runtime. Cela implique qu'elle ne peut pas \u00eatre modifi\u00e9e au cours de l'ex\u00e9cution du programme, contrairement aux variables uniform par exemple. Les cas d'usage sont donc diff\u00e9rents.</p> <p>Voici un exemple de d\u00e9finition de macro simple :</p> <pre><code>#define PI 3.14159265\n</code></pre> <p>Dans ce cas, chaque occurrence de <code>PI</code> dans le code sera remplac\u00e9e par la valeur <code>3.14159265</code> lors de la compilation.</p> <p>On peut \u00e9galement d\u00e9finir des macros avec des expressions plus complexes, qui agissent comme des fonctions avec des arguments par exemple :</p> <pre><code>#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n</code></pre> <p>Dans ce cas, lorsque la macro <code>MIN</code> est utilis\u00e9e dans le code avec des arguments, elle est remplac\u00e9e par l'expression conditionnelle qui compare les deux arguments et renvoie le plus petit des deux. Par exemple, l'instruction <code>MIN(x, y)</code> sera remplac\u00e9e par <code>((x) &lt; (y) ? (x) : (y))</code>.</p>"},{"location":"fr/Macros/#fichiers-importants","title":"Fichiers importants","text":"<p>Vous trouverez dans le dossier /Macros du repo, les fichiers contenant toutes les macros pr\u00e9 d\u00e9clar\u00e9es par Pixel Wrangle dans vos shader. Libre \u00e0 vous de rajouter les v\u00f4tres. La table suivante liste toutes les macros que Pixel Wrangle met \u00e0 votre disposition.</p>"},{"location":"fr/Macros/#macros-de-variables-accessibles-dans-pixel-wrangle","title":"Macros de variables accessibles dans Pixel Wrangle","text":"Nom de la macro Valeur de la macro Commentaire _PI 3.1415926535897932384626433832795 PI Value (3.14...) _TAU _PI * 2 2 * PI Value _GOLD 1.618033988749894 Golden Ratio _E 2.7182818284590452353602874713527 Euler Number _RES vec2(uTDOutputInfo.res.z,uTDOutputInfo.res.w) 2D Resolution in Pixels _DEPTH uTDOutputInfo.depth.y Depth _RATIO2D vec2(max(_RES.x/_RES.y, 1),max(_RES.y/_RES.x, 1)) Ratio from Max Axis _CENTER 0.5 Center _POS2DN vec2(_POS2D) / _RES 2D Normalized Position (vUV.st) _POS2DC _POS2D - vec2(_RES/2) 2D Centered Position in Pixels _POS2DNC (vec2(_POS2D) / _RES - _CENTER) 2D Normalized + Centered Position _POS2DNR _POS2DN * _RATIO2D 2D Normalized + Ratio Position _POS2DNCR (vec2(_RATIO2D) * vec2(_POS2DN - _CENTER)) 2D Normalized + Centered + Ratio Position _POS3DN vec3(_POS3D) / vec3(_RES.x,_RES.y,_DEPTH) 3D Normalized Position (vUV.stp) _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 _POS3D - vec3(vec2(_RES/2), _DEPTH/2) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN - _CENTER \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN * vec3(_RATIO2D, 1/_DEPTH) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 ( vec3(_RATIO2D, 1/_DEPTH) * (_POS3DN - _CENTER)) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized Position (vUV.st) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _UVNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS2DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Normalized + Centered + Ratio Position \u00a0 _P \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3D \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DN \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized Position (vUV.stp) \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Centered Position in Pixels \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNC \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Ratio Position \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _PNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 _POS3DNCR \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Normalized + Centered + Ratio Position \u00a0 iChannel[0-3]\u00a0 \u00a0 sTD2DInputs[0-3] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-3 (Alias for ShaderToy inputs) example : iChannel0 to access first 2D Input o[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 mTDComputeOutputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Output Buffer 0-7 example : (o0 to access first buffer) i[0-7]_2D \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1_2D to access second 2D input) i[0-7]_3D \u00a0 \u00a0 \u00a0 sTD3DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 3D Input Channel 0-7 example : (i1_3D to access second 3D input) i[0-7]_Array \u00a0 sTD2DArrayInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Array Input Channel 0-7 example : (i3_Array to access fourth 2D Array input) i[0-7]_Cube \u00a0 sTDCubeInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Cube Input Channel 0-7 example : (i3_Cube to access fourth Cube input) i[0-7] \u00a0 \u00a0 \u00a0 sTD2DInputs[0-7] \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Input Channel 0-7 example : (i1 to access second 2D input) fragCoord \u00a0 \u00a0 \u00a0 _UV \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 2D Position in Pixels"},{"location":"fr/Macros/#macros-de-fonctions-accessibles-dans-pixel-wrangle","title":"Macros de fonctions accessibles dans Pixel Wrangle","text":"Nom de la macro Valeur de la macro Commentaire fetch \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texelFetch(IN, POS, LOD) fetch(sampler*D IN, ivec* POS, int LOD OR int SAMPLE) =&gt; vec* tx \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 texture(IN, POS, BIAS) tx(sampler*D IN, vec* POS, float OR vec* OR float[] bias) =&gt; float OR vec4 store \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 imageStore(OUT, POS, VALUE) store(gimage*D OUT, vec* POS, vec* VALUE) =&gt; void (image) td \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 TDOutputSwizzle(COLOR) td(vec4 COLOR) =&gt; vec4"},{"location":"fr/Param%C3%A8tres/","title":"Param\u00e8tres","text":"<p>Pixel-Wrangle met \u00e0 votre disposition de nombreux param\u00e8tres r\u00e9partis en plusieurs page.</p> <p>Chacune des pages g\u00e8re des aspects diff\u00e9rents de Pixel Wrangle. Les modifications apport\u00e9es sont sauvegard\u00e9es avec vos presets. Il est possible d'apporter des modifications via le Component Editor mais je le d\u00e9conseille fortement, dans un soucis de compatibilit\u00e9 avec des versions futures de Pixel Wrangle</p> <p>Voici un aper\u00e7u g\u00e9n\u00e9ral :</p> <ul> <li> <p>La page 'Controls' : Ce sont tout les param\u00e8tres li\u00e9s aux variables que vous avez d\u00e9clar\u00e9 dans le panneau 'Inputs'. Ces param\u00e8tres sont ajout\u00e9s dynamiquement en fonction de votre shader. Vous pouvez \u00e9galement faire des modifications depuis le 'Component Editor' de l'instance de Pixel Wrangle si vous le souhaitez, bien que le mieux reste de le faire explicitement dans le Panneau 'Inputs' via les propri\u00e9t\u00e9s.</p> </li> <li> <p>La page 'Code' : C'est ici que vous pouvez r\u00e9gler les principales fonctionnalit\u00e9s sp\u00e9cifiques \u00e0 Pixel Wrangle comme les chemins vers la librairie principale, vers Visual Studio Code, les param\u00e8tres li\u00e9s \u00e0 l'apparence de l'UI, etc.</p> </li> <li> <p>La page 'Inputs' : Vous d\u00e9finissez ici les entr\u00e9es du shader comme leur nom, les diff\u00e9rents modes (Direct, Feedback, Custom), et d'autres options li\u00e9s aux entr\u00e9es de votre shader</p> </li> <li> <p>La page 'Outputs' : C'est ici que vous d\u00e9finissez les sorties du shader, leur nom, etc.</p> </li> <li> <p>La page 'GLSL' : Param\u00e8tres li\u00e9s au GLSL TOP sous-jacent. Comme le mode, la version de GLSL, etc.</p> </li> <li> <p>La page 'Globals' : Param\u00e8tres globaux du shader, comme la r\u00e9solution de sortie, le bit depth, etc.</p> </li> </ul>"},{"location":"fr/Param%C3%A8tres/#page-controls","title":"Page Controls","text":"<p>Comme \u00e9voqu\u00e9 pr\u00e9c\u00e9demment, la page 'Controls' repr\u00e9sente toutes les d\u00e9clarations de variable effectu\u00e9es dans le Panneau 'Inputs'. Vous pouvez modifier la forme de ce panneau de contr\u00f4le et de chacun des param\u00e8tres via des propri\u00e9t\u00e9s ajout\u00e9es en tant que commentaire dans vos d\u00e9clarations (comme min, max, default, etc.) Cette page est donc g\u00e9n\u00e9r\u00e9e dynamiquement en fonction du code \u00e9crit dans le panneau 'Inputs' Si vous souhaitez utiliser le Component Editor pour faire des modifications sur un param\u00e8tre vous le pouvez, mais globalement je le d\u00e9conseille pour une question de portabilit\u00e9 de vos preset dans des versions futures de Pixel Wrangle. Il est \u00e9galement a noter que toute modification effectu\u00e9e par le Component Editor sera \u00e9cras\u00e9e si vous modifiez apr\u00e8s coup les propri\u00e9t\u00e9s de ce param\u00e8tre dans le panneau Inputs Vous trouverez ici quelques exemples pour ajouter des param\u00e8tres sur la page via le panneau 'Inputs'</p>"},{"location":"fr/Param%C3%A8tres/#page-code","title":"Page Code","text":"<p>La page Code regroupe toutes les options relatives \u00e0 Pixel Wrangle, voici la liste des param\u00e8tres disponibles :</p> Parameter Label Description Help Ouvrir l'aide en ligne Presets Folder Chemin du dossier des Presets Update Folders Forcer la mise \u00e0 jour du contenu des dossiers de Presets Open Presets Folder Ouvrir le dossier des Presets avec l'explorateur de fichier de votre syst\u00e8me, [CTRL] + O Open Functions Folder Ouvrir le dossier des Fonctions avec l'explorateur de fichier de votre syst\u00e8me, [CTRL] + [SHIFT] + O Compile Mode Lazy : Recompiler le shader lorsque le focus du panneau d'\u00e9dition du code est perdu, Continuous : Recompiler apr\u00e8s chaque modification Word Wrap Replier automatiquement le code sur plusieurs lignes quand il d\u00e9passe la taille du panneau Code Font D\u00e9finir la police d'\u00e9criture utilis\u00e9e pour le code UI Font D\u00e9finir la police d'\u00e9criture utilis\u00e9e pour l'UI Font Size Ajuster la taille de police globale Line height D\u00e9finir la hauteur de ligne Main Color D\u00e9finir la couleur principale du fond Disable UI D\u00e9sactive totalement l'UI Open as Perform Ouvrir la fen\u00eatre en mode Perform (sans l'UI de Touchdesigner), [F1] pour ouvrir, [ESC] pour fermer Open as Separate Ouvrir la fen\u00eatre en mode s\u00e9par\u00e9 (l'UI de Touchdesigner reste accessible), [CTRL] + [ENTER] pour ouvrir, [ESC] pour fermer Set as Perform D\u00e9finir l'instance de Pixel Wrangle comme fen\u00eatre par d\u00e9faut en mode Perform, [CTRL] + [F1] pour activer Window Placement Dialog Ouvre le panneau de gestions des fen\u00eatres Perform de Touchdesigner Close Fermer les fen\u00eatres actives de l'instance de Pixel Wrangle Library Path Chemin Racine de Pixel Wrangle Rebuild Libs Ex\u00e9cute le script de parsing sur les biblioth\u00e8ques de Fonctions situ\u00e9es dans &lt;\\PixelWranleRootPath&gt;/Functions/src afin de les rendre compatibles avec Touchdesigner Update Imported Libs Importe les librairies compatibles \u00e0 la racine du projet courant dans un baseCOMP situ\u00e9 au chemin /libs"},{"location":"fr/Param%C3%A8tres/#page-inputs","title":"Page Inputs","text":"<p>La page 'Inputs' regroupe tous les param\u00e8tres relatifs aux entr\u00e9es de shader.</p> <p>Ci dessous vous trouverez la liste compl\u00e8te des param\u00e8tres disponibles :</p> Parameter Label Description Play Active la d\u00e9pendance au temps (cook every frame) Run independently Rends le temps ind\u00e9pendant du start-stop global Panel Source S\u00e9lectionne le panneau de r\u00e9f\u00e9rence pour les interactions de souris Panel CHOP Si Panel Source est 'Custom', r\u00e9f\u00e9rencer le PanelCOMP utilis\u00e9 pour les interactions de souris Smooth Mouse Active un lag sur les mouvements de souris pour lisser les trajectoires du pointeur Lag Sp\u00e9cifier le lissage en secondes pour le lissage de la souris Reset All R\u00e9initialise toutes les entr\u00e9es qui sont en mode 'Feedback' Active Active l'entr\u00e9e de shader correspondante Name Nom de l'entr\u00e9e (celui affich\u00e9 au survol de l'entr\u00e9e) Color D\u00e9finir la couleur de l'entr\u00e9e correspondante Type Direct : Branchement en direct d'un OP dans l'entr\u00e9e, Feedback : R\u00e9cup\u00e9rer le signal depuis une des sorties de shader (previous frame), Custom : TOP personnalis\u00e9 Fallback TOP utilis\u00e9 lorsque l'entr\u00e9e n'est pas branch\u00e9e ou non conforme TOP Si Type est 'Custom', Chemin du TOP \u00e0 utiliser pour l'entr\u00e9e correspondante Reset Si Type est 'Feedback', R\u00e9initialise l'entr\u00e9e correspondante Feedback Source Si Type est 'Feedback', S\u00e9lectionne la sortie de shader s\u00e9lectionn\u00e9e Feedback Init Type Si Type est 'Feedback', S\u00e9lectionne le type de signal d'initialisation Feedback Init Output Si Type est 'Feedback' et Feedback Init Type est 'Output', utilise la sortie de shader s\u00e9lectionn\u00e9e comme signal d'initialisation Feedback Init Built-in Si Type est 'Feedback' et Feedback Init Type est 'Built-in', utilise le built-in s\u00e9lectionn\u00e9e comme signal d'initialisation Feedback Init Built-in Si Type est 'Feedback' et Feedback Init Type est 'Custom', utilise le TOP indiqu\u00e9 comme signal d'initialisation"},{"location":"fr/Param%C3%A8tres/#page-outputs","title":"Page Outputs","text":"<p>La page 'Outputs' regroupe tous les param\u00e8tres relatifs aux entr\u00e9es de shader.</p> <p>Ci dessous vous trouverez la liste compl\u00e8te des param\u00e8tres disponibles :</p> Parameter Label Description Active Active l'entr\u00e9e de shader correspondante Name Nom de l'entr\u00e9e (celui affich\u00e9 au survol de l'entr\u00e9e) Color D\u00e9finir la couleur de l'entr\u00e9e correspondante"},{"location":"fr/Param%C3%A8tres/#page-glsl","title":"Page GLSL","text":"<p>La page GLSL regroupe tous les param\u00e8tres disponibles sur le page GLSL d'un GLSL TOP Le plus simple est donc de vous r\u00e9f\u00e9rer \u00e0 la documentation de Touchdesigner qui fournira une liste compl\u00e8te des options r\u00e9glables. Le seul param\u00e8tre qui diff\u00e8re est 'Local Size' disponible en mode 'Compute shader'. Il d\u00e9finit la taille du thread (le nombre de pixels envoy\u00e9s simultan\u00e9ment au GPU pour traitement par le shader). Habituellement ce param\u00e8tre est d\u00e9clar\u00e9 sous forme de code dans le shader, mais ici vous pouvez le d\u00e9finir dans un param\u00e8tre TD directement.</p>"},{"location":"fr/Param%C3%A8tres/#page-globals","title":"Page Globals","text":"<p>La page Global d\u00e9finit les param\u00e8tre globaux de Pixel Wrangle, comme la r\u00e9solution, l'aspect, etc.) Ces param\u00e8tre correspondent \u00e0 ceux que vous pourriez trouver sur n'importe quel TOP (sur la page Common) dans Touchdesigner. Vous pouvez donc par exemple vous r\u00e9f\u00e9rer \u00e0 la documentation d'un GLSL TOP pour en savoir plus.</p>"},{"location":"fr/Presets/","title":"Presets","text":""},{"location":"fr/Presets/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>Pixel Wrangle dispose d'un syst\u00e8me de gestion de pr\u00e9r\u00e9glages. Ces pr\u00e9r\u00e9glages sont appel\u00e9s 'preset'</p> <p>Un preset Pixel-Wrangle contient \u00e0 la fois tout le code que vous avez \u00e9crit dans chacun des panneaux du shader, ainsi que tous les param\u00e8tres et leur \u00e9tat au moment de la sauvegarde.</p> <p>Afin de faciliter le chargement et le filtrage des presets, Pixel Wrangle fournit un explorateur basique avec une hi\u00e9rarchie fichiers/dossiers qui refl\u00e8te la structure de votre syst\u00e8me de fichier</p> <p>L'explorateur vous permet de trouver, charger ou sauver des pr\u00e9r\u00e9glages.</p> <p>Il est activable en cliquant sur la zone de recherche situ\u00e9e en bas \u00e0 gauche de l'interface ou via le raccourci [CTRL] + Tab.</p> <p>Vous pouvez ainsi taper le nom de votre recherche afin de filtrer les r\u00e9sultats ou d\u00e9rouler l'architecture.</p>"},{"location":"fr/Presets/#chemins-importants","title":"Chemins importants","text":"<p>Les presets sont stock\u00e9s par d\u00e9faut dans le dossier Presets \u00e0 la racine de Pixel Wrangle dans votre Palette.  </p> <p>Il y a 2 dossiers principaux :  - Builtins : C'est le dossier des presets livr\u00e9s avec Pixel Wrangle - User : C'est le dossier o\u00f9 sont sauv\u00e9s par d\u00e9faut vos presets</p> <p>NB : Si vous souhaitez construire votre propre architecture dans votre dossier User, vous pouvez le faire depuis l'explorateur de fichier de votre syst\u00e8me via un clic sur l'icone de dossier en bas \u00e0 gauche de l'interface ou le raccourci [CTRL] + O. Tout les sous-dossiers cr\u00e9\u00e9s sont refl\u00e9t\u00e9s dans l'explorateur de Pixel Wrangle.</p>"},{"location":"fr/Presets/#charger-un-preset","title":"Charger un preset","text":"<p>Pour charger un preset, il vous suffit de double cliquer dessus depuis l'explorateur de Pixel Wrangle.</p> <p>Attention, parfois le chargement peut \u00eatre erratique, vous devrez peut-\u00eatre effectuer un double-clic \u00e0 plusieurs reprises. Ceci est un bug connu qui devrait \u00eatre fix\u00e9 sur les prochaines version de Pixel Wrangle</p>"},{"location":"fr/Presets/#sauver-un-preset","title":"Sauver un preset","text":"<p>Pour sauver l'\u00e9tat de votre shader dans un nouveau preset, vous pouvez cliquer sur '+' dans l'UI. Cela vous ouvrira un pop-up qui vous demandera sous quel nom vous souhaitez sauvegarder ce pr\u00e9r\u00e9glage. Par d\u00e9faut, ce preset sera sauv\u00e9 dans le dossier Presets/User depuis la racine de Pixel Wrangle dans votre Palette</p>"},{"location":"fr/Raccourcis%20claviers/","title":"Les raccourcis clavier","text":""},{"location":"fr/Raccourcis%20claviers/#dans-le-network-editor-avec-linstance-pixel-wrangle-en-tant-que-current-op-bordures-vertes","title":"Dans le Network Editor avec l'instance Pixel Wrangle en tant que 'Current OP' (Bordures vertes)","text":"Raccourci clavier Action [CTRL] + Enter Open Viewer in separate window for current selected Instance of Pixel Wrangle Escape Close Viewer for current selected Instance of Pixel Wrangle [CTRL] + F1 Set Perform window for current selected instance of Pixel Wrangle F1 Open Perform Window"},{"location":"fr/Raccourcis%20claviers/#dans-la-fenetre-ui-globale-de-linstance-courante","title":"Dans la fen\u00eatre UI globale de l'instance courante","text":"Raccourci clavier Action [CTRL] + 1 Switch to IO Tab [CTRL] + 2 Switch to Functions Tab [CTRL] + 3 Switch to Main Tab [CTRL] + 0 Toggle Full Screen Viewer [CTRL] + 9 Toggle Full Code Panel (Read-Only) [CTRL] + M Toggle Macros Panel (Read-Only) [CTRL] + T Toggle Time Dependency [CTRL] + P Toggle Parameter Panel [CTRL] + [SHIFT] + P Toggle Viewer in Parameter Panel [CTRL] + Tab Open Preset Loader Panel [CTRL] + [SHIFT] + Tab Open Functions Loader Panel"},{"location":"fr/Raccourcis%20claviers/#dans-longlet-main","title":"Dans l'onglet Main","text":"Raccourci clavier Action [CTRL] + [SHIFT] + 1 Toggle IO Tab in Main Tab on Left Side [CTRL] + [SHIFT] + 2 Toggle Functions Tab in Main Tab on Right Side"},{"location":"fr/Raccourcis%20claviers/#dans-un-viewer","title":"Dans un Viewer","text":"<p>Tous les raccourcis des TOP sont accessibles + la liste suivante :</p> Raccourci clavier Action [1-8] Switch Tab on corresponding Output Holding [CTRL] + Click Interaction Mode (Mouse Position, Mouse Clicks)"},{"location":"fr/VSCode/","title":"Visual Studio Code","text":""},{"location":"fr/VSCode/#introduction","title":"Introduction","text":"<p>Pixel Wrangle propose par d\u00e9faut la possibilit\u00e9 d'\u00e9diter le code de vos shaders au sein de Visual Studio Code.</p> <p>Visual Studio Code est un \u00e9diteur de code tr\u00e8s populaire propos\u00e9 par Microsoft, il est gratuit et dispose d'un \u00e9cosyst\u00e8me d'extension tr\u00e8s large.</p> <p>Pour plus d'informations, vous pouvez consulter le site officiel de Visual Studio Code</p>"},{"location":"fr/VSCode/#configuration","title":"Configuration","text":"<p>Pour profiter de l'int\u00e9gration de Visual Studio Code au sein de Pixel Wrangle, vous devez pr\u00e9alablement d\u00e9finir le chemin qui pointe vers l'ex\u00e9cutable de Visual Studio Code.</p> <p>Par d\u00e9faut il se situe :</p> <ul> <li>Soit dans votre dossier personnel (si vous effectuez une installation pour votre compte utilisateur uniquement) =&gt; C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe</li> <li>Soit dans votre partition syst\u00e8me (si vous effectuez une installation pour tout les utilisateur -&gt;  requiert les droits Administrateur) =&gt; C:\\ProgramData\\Microsoft VS Code\\Code.exe</li> </ul> <p>Pour d\u00e9finir le chemin de Visual Studio Code, vous avez 2 possibilit\u00e9s</p> <ul> <li> <p>Via l'interface de Pixel Wrangle : (Si le param\u00e8tre est bloqu\u00e9, vous pouvez faire un clic droit puis toggle read-only afin d'activer le mode 'Edition') </p> </li> <li> <p>Via le fichier settings.json situ\u00e9 dans le dossier racine du projet : </p> </li> </ul> <p>Une fois cela fait, vous pourrez lancer l'\u00e9dition de votre code dans l'\u00e9diteur Visual Studio Code en pressant le bouton correspondant dans l'UI, ou en pressant [CTRL] + E dans l'UI. Ce chemin sera ensuite commun \u00e0 toutes vos instances de Pixel Wrangle dans tout vos projets.</p>"},{"location":"fr/VSCode/#environnement","title":"Environnement","text":"<p>Par d\u00e9faut, au premier lancement de Visual Studio Code via Pixel Wrangle, un nouvel environnement de travail Visual Studio Code est cr\u00e9\u00e9. Il sera utilis\u00e9 par la suite d\u00e8s lors que vous ouvrirez Visual Studio Code via une instance de Pixel Wrangle. L'objectif est que cela n'interf\u00e8re pas avec vos environnements Visual Studio Code existants ainsi que vous permettre de le personnaliser \u00e0 votre go\u00fbt (raccourcis, extensions, etc). De plus, cet environnement sera conserv\u00e9 au fur et \u00e0 mesure des updates de Pixel Wrangle car il est stock\u00e9 localement sur votre machine et reste ind\u00e9pendant de l'installation de Pixel Wrangle Par d\u00e9faut, l'emplacement de cet environnement est : C:\\Users\\&lt;YOUR-USER-ACCOUNT-NAME&gt;\\.vscode-td\\glsl</p>"},{"location":"fr/VSCode/#emplacement-des-fichiers-temporaires-de-pixel-wrangle","title":"Emplacement des fichiers temporaires de Pixel Wrangle","text":"<p>Lorsque vous \u00e9crivez du code dans Pixel Wrangle, \u00e0 chaque modification, les fichiers sont sauv\u00e9s sur le disque dur. L'emplacement de ces fichiers se situe dans le dossier temporaire de Touchdesigner g\u00e9n\u00e9ralement situ\u00e9 dans</p>"},{"location":"fr/VSCode/#profil-code-profile-fourni","title":"Profil .code-profile fourni","text":"<p>Pour commencer, Pixel Wrangle propose un profil Visual Studio Code qui propose un jeu d'extensions, de raccourcis claviers. Cette configuration est volontairement minimaliste et adapt\u00e9e pour l'\u00e9criture de GLSL. Par ailleurs, quelques variables sp\u00e9cifiques \u00e0 l'environnement GLSL dans Touchdesigner sont inject\u00e9es, ce qui permet d'avoir une meilleure auto-compl\u00e9tion sans avoir \u00e0 r\u00e9aliser d'imports.</p> <p>Vous pouvez charger directement ce profil dans Visual Studio Code via la palette de commande ([CTRL] + [SHIFT] + P), et lancer la commande : 'Import Settings Profile'</p> <p></p> <p>Si vous souhaitez charger ce fichier de profil dans votre environnement, vous pouvez aller le chercher \u00e0 la racine du projet Pixel Wrangle dans votre Palette</p> <p></p>"}]}